// Code generated by Prisma (prisma@1.34.6). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  address: (where?: AddressWhereInput) => Promise<boolean>;
  analyzeCustomerForm: (
    where?: AnalyzeCustomerFormWhereInput
  ) => Promise<boolean>;
  branch: (where?: BranchWhereInput) => Promise<boolean>;
  buisness: (where?: BuisnessWhereInput) => Promise<boolean>;
  contact: (where?: ContactWhereInput) => Promise<boolean>;
  criteriaCalculator: (
    where?: CriteriaCalculatorWhereInput
  ) => Promise<boolean>;
  customer: (where?: CustomerWhereInput) => Promise<boolean>;
  lead: (where?: LeadWhereInput) => Promise<boolean>;
  mainProject: (where?: MainProjectWhereInput) => Promise<boolean>;
  mainProjectPhases: (where?: MainProjectPhasesWhereInput) => Promise<boolean>;
  permission: (where?: PermissionWhereInput) => Promise<boolean>;
  permissionAction: (where?: PermissionActionWhereInput) => Promise<boolean>;
  phaseFormsPayload: (where?: PhaseFormsPayloadWhereInput) => Promise<boolean>;
  phasePayload: (where?: PhasePayloadWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  projectForms: (where?: ProjectFormsWhereInput) => Promise<boolean>;
  projectManager: (where?: ProjectManagerWhereInput) => Promise<boolean>;
  projectPhase: (where?: ProjectPhaseWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  address: (where: AddressWhereUniqueInput) => AddressNullablePromise;
  addresses: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Address>;
  addressesConnection: (args?: {
    where?: AddressWhereInput;
    orderBy?: AddressOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AddressConnectionPromise;
  analyzeCustomerForm: (
    where: AnalyzeCustomerFormWhereUniqueInput
  ) => AnalyzeCustomerFormNullablePromise;
  analyzeCustomerForms: (args?: {
    where?: AnalyzeCustomerFormWhereInput;
    orderBy?: AnalyzeCustomerFormOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AnalyzeCustomerForm>;
  analyzeCustomerFormsConnection: (args?: {
    where?: AnalyzeCustomerFormWhereInput;
    orderBy?: AnalyzeCustomerFormOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AnalyzeCustomerFormConnectionPromise;
  branch: (where: BranchWhereUniqueInput) => BranchNullablePromise;
  branches: (args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Branch>;
  branchesConnection: (args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BranchConnectionPromise;
  buisness: (where: BuisnessWhereUniqueInput) => BuisnessNullablePromise;
  buisnesses: (args?: {
    where?: BuisnessWhereInput;
    orderBy?: BuisnessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Buisness>;
  buisnessesConnection: (args?: {
    where?: BuisnessWhereInput;
    orderBy?: BuisnessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BuisnessConnectionPromise;
  contact: (where: ContactWhereUniqueInput) => ContactNullablePromise;
  contacts: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Contact>;
  contactsConnection: (args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContactConnectionPromise;
  criteriaCalculator: (
    where: CriteriaCalculatorWhereUniqueInput
  ) => CriteriaCalculatorNullablePromise;
  criteriaCalculators: (args?: {
    where?: CriteriaCalculatorWhereInput;
    orderBy?: CriteriaCalculatorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CriteriaCalculator>;
  criteriaCalculatorsConnection: (args?: {
    where?: CriteriaCalculatorWhereInput;
    orderBy?: CriteriaCalculatorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CriteriaCalculatorConnectionPromise;
  customer: (where: CustomerWhereUniqueInput) => CustomerNullablePromise;
  customers: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Customer>;
  customersConnection: (args?: {
    where?: CustomerWhereInput;
    orderBy?: CustomerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CustomerConnectionPromise;
  lead: (where: LeadWhereUniqueInput) => LeadNullablePromise;
  leads: (args?: {
    where?: LeadWhereInput;
    orderBy?: LeadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Lead>;
  leadsConnection: (args?: {
    where?: LeadWhereInput;
    orderBy?: LeadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LeadConnectionPromise;
  mainProject: (
    where: MainProjectWhereUniqueInput
  ) => MainProjectNullablePromise;
  mainProjects: (args?: {
    where?: MainProjectWhereInput;
    orderBy?: MainProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MainProject>;
  mainProjectsConnection: (args?: {
    where?: MainProjectWhereInput;
    orderBy?: MainProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MainProjectConnectionPromise;
  mainProjectPhases: (
    where: MainProjectPhasesWhereUniqueInput
  ) => MainProjectPhasesNullablePromise;
  mainProjectPhaseses: (args?: {
    where?: MainProjectPhasesWhereInput;
    orderBy?: MainProjectPhasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MainProjectPhases>;
  mainProjectPhasesesConnection: (args?: {
    where?: MainProjectPhasesWhereInput;
    orderBy?: MainProjectPhasesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MainProjectPhasesConnectionPromise;
  permission: (where: PermissionWhereUniqueInput) => PermissionNullablePromise;
  permissions: (args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Permission>;
  permissionsConnection: (args?: {
    where?: PermissionWhereInput;
    orderBy?: PermissionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PermissionConnectionPromise;
  permissionAction: (
    where: PermissionActionWhereUniqueInput
  ) => PermissionActionNullablePromise;
  permissionActions: (args?: {
    where?: PermissionActionWhereInput;
    orderBy?: PermissionActionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PermissionAction>;
  permissionActionsConnection: (args?: {
    where?: PermissionActionWhereInput;
    orderBy?: PermissionActionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PermissionActionConnectionPromise;
  phaseFormsPayload: (
    where: PhaseFormsPayloadWhereUniqueInput
  ) => PhaseFormsPayloadNullablePromise;
  phaseFormsPayloads: (args?: {
    where?: PhaseFormsPayloadWhereInput;
    orderBy?: PhaseFormsPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PhaseFormsPayload>;
  phaseFormsPayloadsConnection: (args?: {
    where?: PhaseFormsPayloadWhereInput;
    orderBy?: PhaseFormsPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhaseFormsPayloadConnectionPromise;
  phasePayload: (
    where: PhasePayloadWhereUniqueInput
  ) => PhasePayloadNullablePromise;
  phasePayloads: (args?: {
    where?: PhasePayloadWhereInput;
    orderBy?: PhasePayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PhasePayload>;
  phasePayloadsConnection: (args?: {
    where?: PhasePayloadWhereInput;
    orderBy?: PhasePayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PhasePayloadConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  project: (where: ProjectWhereUniqueInput) => ProjectNullablePromise;
  projects: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Project>;
  projectsConnection: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectConnectionPromise;
  projectForms: (
    where: ProjectFormsWhereUniqueInput
  ) => ProjectFormsNullablePromise;
  projectFormses: (args?: {
    where?: ProjectFormsWhereInput;
    orderBy?: ProjectFormsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProjectForms>;
  projectFormsesConnection: (args?: {
    where?: ProjectFormsWhereInput;
    orderBy?: ProjectFormsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectFormsConnectionPromise;
  projectManager: (
    where: ProjectManagerWhereUniqueInput
  ) => ProjectManagerNullablePromise;
  projectManagers: (args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProjectManager>;
  projectManagersConnection: (args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectManagerConnectionPromise;
  projectPhase: (
    where: ProjectPhaseWhereUniqueInput
  ) => ProjectPhaseNullablePromise;
  projectPhases: (args?: {
    where?: ProjectPhaseWhereInput;
    orderBy?: ProjectPhaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProjectPhase>;
  projectPhasesConnection: (args?: {
    where?: ProjectPhaseWhereInput;
    orderBy?: ProjectPhaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectPhaseConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (args: {
    data: AddressUpdateInput;
    where: AddressWhereUniqueInput;
  }) => AddressPromise;
  updateManyAddresses: (args: {
    data: AddressUpdateManyMutationInput;
    where?: AddressWhereInput;
  }) => BatchPayloadPromise;
  upsertAddress: (args: {
    where: AddressWhereUniqueInput;
    create: AddressCreateInput;
    update: AddressUpdateInput;
  }) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createAnalyzeCustomerForm: (
    data: AnalyzeCustomerFormCreateInput
  ) => AnalyzeCustomerFormPromise;
  updateAnalyzeCustomerForm: (args: {
    data: AnalyzeCustomerFormUpdateInput;
    where: AnalyzeCustomerFormWhereUniqueInput;
  }) => AnalyzeCustomerFormPromise;
  updateManyAnalyzeCustomerForms: (args: {
    data: AnalyzeCustomerFormUpdateManyMutationInput;
    where?: AnalyzeCustomerFormWhereInput;
  }) => BatchPayloadPromise;
  upsertAnalyzeCustomerForm: (args: {
    where: AnalyzeCustomerFormWhereUniqueInput;
    create: AnalyzeCustomerFormCreateInput;
    update: AnalyzeCustomerFormUpdateInput;
  }) => AnalyzeCustomerFormPromise;
  deleteAnalyzeCustomerForm: (
    where: AnalyzeCustomerFormWhereUniqueInput
  ) => AnalyzeCustomerFormPromise;
  deleteManyAnalyzeCustomerForms: (
    where?: AnalyzeCustomerFormWhereInput
  ) => BatchPayloadPromise;
  createBranch: (data: BranchCreateInput) => BranchPromise;
  updateBranch: (args: {
    data: BranchUpdateInput;
    where: BranchWhereUniqueInput;
  }) => BranchPromise;
  updateManyBranches: (args: {
    data: BranchUpdateManyMutationInput;
    where?: BranchWhereInput;
  }) => BatchPayloadPromise;
  upsertBranch: (args: {
    where: BranchWhereUniqueInput;
    create: BranchCreateInput;
    update: BranchUpdateInput;
  }) => BranchPromise;
  deleteBranch: (where: BranchWhereUniqueInput) => BranchPromise;
  deleteManyBranches: (where?: BranchWhereInput) => BatchPayloadPromise;
  createBuisness: (data: BuisnessCreateInput) => BuisnessPromise;
  updateBuisness: (args: {
    data: BuisnessUpdateInput;
    where: BuisnessWhereUniqueInput;
  }) => BuisnessPromise;
  updateManyBuisnesses: (args: {
    data: BuisnessUpdateManyMutationInput;
    where?: BuisnessWhereInput;
  }) => BatchPayloadPromise;
  upsertBuisness: (args: {
    where: BuisnessWhereUniqueInput;
    create: BuisnessCreateInput;
    update: BuisnessUpdateInput;
  }) => BuisnessPromise;
  deleteBuisness: (where: BuisnessWhereUniqueInput) => BuisnessPromise;
  deleteManyBuisnesses: (where?: BuisnessWhereInput) => BatchPayloadPromise;
  createContact: (data: ContactCreateInput) => ContactPromise;
  updateContact: (args: {
    data: ContactUpdateInput;
    where: ContactWhereUniqueInput;
  }) => ContactPromise;
  updateManyContacts: (args: {
    data: ContactUpdateManyMutationInput;
    where?: ContactWhereInput;
  }) => BatchPayloadPromise;
  upsertContact: (args: {
    where: ContactWhereUniqueInput;
    create: ContactCreateInput;
    update: ContactUpdateInput;
  }) => ContactPromise;
  deleteContact: (where: ContactWhereUniqueInput) => ContactPromise;
  deleteManyContacts: (where?: ContactWhereInput) => BatchPayloadPromise;
  createCriteriaCalculator: (
    data: CriteriaCalculatorCreateInput
  ) => CriteriaCalculatorPromise;
  updateCriteriaCalculator: (args: {
    data: CriteriaCalculatorUpdateInput;
    where: CriteriaCalculatorWhereUniqueInput;
  }) => CriteriaCalculatorPromise;
  updateManyCriteriaCalculators: (args: {
    data: CriteriaCalculatorUpdateManyMutationInput;
    where?: CriteriaCalculatorWhereInput;
  }) => BatchPayloadPromise;
  upsertCriteriaCalculator: (args: {
    where: CriteriaCalculatorWhereUniqueInput;
    create: CriteriaCalculatorCreateInput;
    update: CriteriaCalculatorUpdateInput;
  }) => CriteriaCalculatorPromise;
  deleteCriteriaCalculator: (
    where: CriteriaCalculatorWhereUniqueInput
  ) => CriteriaCalculatorPromise;
  deleteManyCriteriaCalculators: (
    where?: CriteriaCalculatorWhereInput
  ) => BatchPayloadPromise;
  createCustomer: (data: CustomerCreateInput) => CustomerPromise;
  updateCustomer: (args: {
    data: CustomerUpdateInput;
    where: CustomerWhereUniqueInput;
  }) => CustomerPromise;
  updateManyCustomers: (args: {
    data: CustomerUpdateManyMutationInput;
    where?: CustomerWhereInput;
  }) => BatchPayloadPromise;
  upsertCustomer: (args: {
    where: CustomerWhereUniqueInput;
    create: CustomerCreateInput;
    update: CustomerUpdateInput;
  }) => CustomerPromise;
  deleteCustomer: (where: CustomerWhereUniqueInput) => CustomerPromise;
  deleteManyCustomers: (where?: CustomerWhereInput) => BatchPayloadPromise;
  createLead: (data: LeadCreateInput) => LeadPromise;
  updateLead: (args: {
    data: LeadUpdateInput;
    where: LeadWhereUniqueInput;
  }) => LeadPromise;
  updateManyLeads: (args: {
    data: LeadUpdateManyMutationInput;
    where?: LeadWhereInput;
  }) => BatchPayloadPromise;
  upsertLead: (args: {
    where: LeadWhereUniqueInput;
    create: LeadCreateInput;
    update: LeadUpdateInput;
  }) => LeadPromise;
  deleteLead: (where: LeadWhereUniqueInput) => LeadPromise;
  deleteManyLeads: (where?: LeadWhereInput) => BatchPayloadPromise;
  createMainProject: (data: MainProjectCreateInput) => MainProjectPromise;
  updateMainProject: (args: {
    data: MainProjectUpdateInput;
    where: MainProjectWhereUniqueInput;
  }) => MainProjectPromise;
  updateManyMainProjects: (args: {
    data: MainProjectUpdateManyMutationInput;
    where?: MainProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertMainProject: (args: {
    where: MainProjectWhereUniqueInput;
    create: MainProjectCreateInput;
    update: MainProjectUpdateInput;
  }) => MainProjectPromise;
  deleteMainProject: (where: MainProjectWhereUniqueInput) => MainProjectPromise;
  deleteManyMainProjects: (
    where?: MainProjectWhereInput
  ) => BatchPayloadPromise;
  createMainProjectPhases: (
    data: MainProjectPhasesCreateInput
  ) => MainProjectPhasesPromise;
  updateMainProjectPhases: (args: {
    data: MainProjectPhasesUpdateInput;
    where: MainProjectPhasesWhereUniqueInput;
  }) => MainProjectPhasesPromise;
  upsertMainProjectPhases: (args: {
    where: MainProjectPhasesWhereUniqueInput;
    create: MainProjectPhasesCreateInput;
    update: MainProjectPhasesUpdateInput;
  }) => MainProjectPhasesPromise;
  deleteMainProjectPhases: (
    where: MainProjectPhasesWhereUniqueInput
  ) => MainProjectPhasesPromise;
  deleteManyMainProjectPhaseses: (
    where?: MainProjectPhasesWhereInput
  ) => BatchPayloadPromise;
  createPermission: (data: PermissionCreateInput) => PermissionPromise;
  updatePermission: (args: {
    data: PermissionUpdateInput;
    where: PermissionWhereUniqueInput;
  }) => PermissionPromise;
  updateManyPermissions: (args: {
    data: PermissionUpdateManyMutationInput;
    where?: PermissionWhereInput;
  }) => BatchPayloadPromise;
  upsertPermission: (args: {
    where: PermissionWhereUniqueInput;
    create: PermissionCreateInput;
    update: PermissionUpdateInput;
  }) => PermissionPromise;
  deletePermission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  deleteManyPermissions: (where?: PermissionWhereInput) => BatchPayloadPromise;
  createPermissionAction: (
    data: PermissionActionCreateInput
  ) => PermissionActionPromise;
  updatePermissionAction: (args: {
    data: PermissionActionUpdateInput;
    where: PermissionActionWhereUniqueInput;
  }) => PermissionActionPromise;
  updateManyPermissionActions: (args: {
    data: PermissionActionUpdateManyMutationInput;
    where?: PermissionActionWhereInput;
  }) => BatchPayloadPromise;
  upsertPermissionAction: (args: {
    where: PermissionActionWhereUniqueInput;
    create: PermissionActionCreateInput;
    update: PermissionActionUpdateInput;
  }) => PermissionActionPromise;
  deletePermissionAction: (
    where: PermissionActionWhereUniqueInput
  ) => PermissionActionPromise;
  deleteManyPermissionActions: (
    where?: PermissionActionWhereInput
  ) => BatchPayloadPromise;
  createPhaseFormsPayload: (
    data: PhaseFormsPayloadCreateInput
  ) => PhaseFormsPayloadPromise;
  updatePhaseFormsPayload: (args: {
    data: PhaseFormsPayloadUpdateInput;
    where: PhaseFormsPayloadWhereUniqueInput;
  }) => PhaseFormsPayloadPromise;
  updateManyPhaseFormsPayloads: (args: {
    data: PhaseFormsPayloadUpdateManyMutationInput;
    where?: PhaseFormsPayloadWhereInput;
  }) => BatchPayloadPromise;
  upsertPhaseFormsPayload: (args: {
    where: PhaseFormsPayloadWhereUniqueInput;
    create: PhaseFormsPayloadCreateInput;
    update: PhaseFormsPayloadUpdateInput;
  }) => PhaseFormsPayloadPromise;
  deletePhaseFormsPayload: (
    where: PhaseFormsPayloadWhereUniqueInput
  ) => PhaseFormsPayloadPromise;
  deleteManyPhaseFormsPayloads: (
    where?: PhaseFormsPayloadWhereInput
  ) => BatchPayloadPromise;
  createPhasePayload: (data: PhasePayloadCreateInput) => PhasePayloadPromise;
  updatePhasePayload: (args: {
    data: PhasePayloadUpdateInput;
    where: PhasePayloadWhereUniqueInput;
  }) => PhasePayloadPromise;
  updateManyPhasePayloads: (args: {
    data: PhasePayloadUpdateManyMutationInput;
    where?: PhasePayloadWhereInput;
  }) => BatchPayloadPromise;
  upsertPhasePayload: (args: {
    where: PhasePayloadWhereUniqueInput;
    create: PhasePayloadCreateInput;
    update: PhasePayloadUpdateInput;
  }) => PhasePayloadPromise;
  deletePhasePayload: (
    where: PhasePayloadWhereUniqueInput
  ) => PhasePayloadPromise;
  deleteManyPhasePayloads: (
    where?: PhasePayloadWhereInput
  ) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (args: {
    data: ProjectUpdateInput;
    where: ProjectWhereUniqueInput;
  }) => ProjectPromise;
  updateManyProjects: (args: {
    data: ProjectUpdateManyMutationInput;
    where?: ProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertProject: (args: {
    where: ProjectWhereUniqueInput;
    create: ProjectCreateInput;
    update: ProjectUpdateInput;
  }) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createProjectForms: (data: ProjectFormsCreateInput) => ProjectFormsPromise;
  updateProjectForms: (args: {
    data: ProjectFormsUpdateInput;
    where: ProjectFormsWhereUniqueInput;
  }) => ProjectFormsPromise;
  upsertProjectForms: (args: {
    where: ProjectFormsWhereUniqueInput;
    create: ProjectFormsCreateInput;
    update: ProjectFormsUpdateInput;
  }) => ProjectFormsPromise;
  deleteProjectForms: (
    where: ProjectFormsWhereUniqueInput
  ) => ProjectFormsPromise;
  deleteManyProjectFormses: (
    where?: ProjectFormsWhereInput
  ) => BatchPayloadPromise;
  createProjectManager: (
    data: ProjectManagerCreateInput
  ) => ProjectManagerPromise;
  updateProjectManager: (args: {
    data: ProjectManagerUpdateInput;
    where: ProjectManagerWhereUniqueInput;
  }) => ProjectManagerPromise;
  updateManyProjectManagers: (args: {
    data: ProjectManagerUpdateManyMutationInput;
    where?: ProjectManagerWhereInput;
  }) => BatchPayloadPromise;
  upsertProjectManager: (args: {
    where: ProjectManagerWhereUniqueInput;
    create: ProjectManagerCreateInput;
    update: ProjectManagerUpdateInput;
  }) => ProjectManagerPromise;
  deleteProjectManager: (
    where: ProjectManagerWhereUniqueInput
  ) => ProjectManagerPromise;
  deleteManyProjectManagers: (
    where?: ProjectManagerWhereInput
  ) => BatchPayloadPromise;
  createProjectPhase: (data: ProjectPhaseCreateInput) => ProjectPhasePromise;
  updateProjectPhase: (args: {
    data: ProjectPhaseUpdateInput;
    where: ProjectPhaseWhereUniqueInput;
  }) => ProjectPhasePromise;
  updateManyProjectPhases: (args: {
    data: ProjectPhaseUpdateManyMutationInput;
    where?: ProjectPhaseWhereInput;
  }) => BatchPayloadPromise;
  upsertProjectPhase: (args: {
    where: ProjectPhaseWhereUniqueInput;
    create: ProjectPhaseCreateInput;
    update: ProjectPhaseUpdateInput;
  }) => ProjectPhasePromise;
  deleteProjectPhase: (
    where: ProjectPhaseWhereUniqueInput
  ) => ProjectPhasePromise;
  deleteManyProjectPhases: (
    where?: ProjectPhaseWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  analyzeCustomerForm: (
    where?: AnalyzeCustomerFormSubscriptionWhereInput
  ) => AnalyzeCustomerFormSubscriptionPayloadSubscription;
  branch: (
    where?: BranchSubscriptionWhereInput
  ) => BranchSubscriptionPayloadSubscription;
  buisness: (
    where?: BuisnessSubscriptionWhereInput
  ) => BuisnessSubscriptionPayloadSubscription;
  contact: (
    where?: ContactSubscriptionWhereInput
  ) => ContactSubscriptionPayloadSubscription;
  criteriaCalculator: (
    where?: CriteriaCalculatorSubscriptionWhereInput
  ) => CriteriaCalculatorSubscriptionPayloadSubscription;
  customer: (
    where?: CustomerSubscriptionWhereInput
  ) => CustomerSubscriptionPayloadSubscription;
  lead: (
    where?: LeadSubscriptionWhereInput
  ) => LeadSubscriptionPayloadSubscription;
  mainProject: (
    where?: MainProjectSubscriptionWhereInput
  ) => MainProjectSubscriptionPayloadSubscription;
  mainProjectPhases: (
    where?: MainProjectPhasesSubscriptionWhereInput
  ) => MainProjectPhasesSubscriptionPayloadSubscription;
  permission: (
    where?: PermissionSubscriptionWhereInput
  ) => PermissionSubscriptionPayloadSubscription;
  permissionAction: (
    where?: PermissionActionSubscriptionWhereInput
  ) => PermissionActionSubscriptionPayloadSubscription;
  phaseFormsPayload: (
    where?: PhaseFormsPayloadSubscriptionWhereInput
  ) => PhaseFormsPayloadSubscriptionPayloadSubscription;
  phasePayload: (
    where?: PhasePayloadSubscriptionWhereInput
  ) => PhasePayloadSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  projectForms: (
    where?: ProjectFormsSubscriptionWhereInput
  ) => ProjectFormsSubscriptionPayloadSubscription;
  projectManager: (
    where?: ProjectManagerSubscriptionWhereInput
  ) => ProjectManagerSubscriptionPayloadSubscription;
  projectPhase: (
    where?: ProjectPhaseSubscriptionWhereInput
  ) => ProjectPhaseSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AnalyzeCustomerFormOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "result_ASC"
  | "result_DESC";

export type LeadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "customerName_ASC"
  | "customerName_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type ProjectFormsOrderByInput = "id_ASC" | "id_DESC";

export type CustomerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "classification_ASC"
  | "classification_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type PermissionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "buisnessObj_ASC"
  | "buisnessObj_DESC";

export type ProjectManagerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "order_ASC"
  | "order_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "profileImage_ASC"
  | "profileImage_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "nickname_ASC"
  | "nickname_DESC"
  | "telephone_ASC"
  | "telephone_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "position_ASC"
  | "position_DESC";

export type CriteriaCalculatorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "required_ASC"
  | "required_DESC"
  | "milestone_ASC"
  | "milestone_DESC";

export type MainProjectPhasesOrderByInput = "id_ASC" | "id_DESC";

export type BranchOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC";

export type ProjectPhaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "status_ASC"
  | "status_DESC";

export type BuisnessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "longDescription_ASC"
  | "longDescription_DESC";

export type PhaseFormsPayloadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "until_ASC"
  | "until_DESC"
  | "required_ASC"
  | "required_DESC"
  | "document_ASC"
  | "document_DESC"
  | "taskTitle_ASC"
  | "taskTitle_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "description_ASC"
  | "description_DESC";

export type ContactOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "profileImage_ASC"
  | "profileImage_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstname_ASC"
  | "firstname_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "nickname_ASC"
  | "nickname_DESC"
  | "telephone_ASC"
  | "telephone_DESC"
  | "mobile_ASC"
  | "mobile_DESC"
  | "position_ASC"
  | "position_DESC"
  | "notes_ASC"
  | "notes_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type MainProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "shortDescription_ASC"
  | "shortDescription_DESC"
  | "status_ASC"
  | "status_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PermissionActionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "postalCode_ASC"
  | "postalCode_DESC"
  | "city_ASC"
  | "city_DESC"
  | "street_ASC"
  | "street_DESC"
  | "country_ASC"
  | "country_DESC";

export type PhasePayloadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "aktiv_ASC"
  | "aktiv_DESC";

export interface ContactUpsertWithWhereUniqueNestedInput {
  where: ContactWhereUniqueInput;
  update: ContactUpdateDataInput;
  create: ContactCreateInput;
}

export type AddressWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CustomerCreateInput {
  id?: Maybe<Int>;
  logo?: Maybe<String>;
  name: String;
  branch?: Maybe<BranchCreateManyInput>;
  classification?: Maybe<String>;
  projectManager?: Maybe<ProjectManagerCreateManyInput>;
  notes?: Maybe<String>;
}

export interface AnalyzeCustomerFormWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  payload?: Maybe<PhaseFormsPayloadWhereInput>;
  result?: Maybe<String>;
  result_not?: Maybe<String>;
  result_in?: Maybe<String[] | String>;
  result_not_in?: Maybe<String[] | String>;
  result_lt?: Maybe<String>;
  result_lte?: Maybe<String>;
  result_gt?: Maybe<String>;
  result_gte?: Maybe<String>;
  result_contains?: Maybe<String>;
  result_not_contains?: Maybe<String>;
  result_starts_with?: Maybe<String>;
  result_not_starts_with?: Maybe<String>;
  result_ends_with?: Maybe<String>;
  result_not_ends_with?: Maybe<String>;
  AND?: Maybe<AnalyzeCustomerFormWhereInput[] | AnalyzeCustomerFormWhereInput>;
  OR?: Maybe<AnalyzeCustomerFormWhereInput[] | AnalyzeCustomerFormWhereInput>;
  NOT?: Maybe<AnalyzeCustomerFormWhereInput[] | AnalyzeCustomerFormWhereInput>;
}

export interface ProjectUpsertWithWhereUniqueWithoutMainProjectInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutMainProjectDataInput;
  create: ProjectCreateWithoutMainProjectInput;
}

export interface ProjectPhaseUpsertWithWhereUniqueNestedInput {
  where: ProjectPhaseWhereUniqueInput;
  update: ProjectPhaseUpdateDataInput;
  create: ProjectPhaseCreateInput;
}

export interface AnalyzeCustomerFormCreateInput {
  id?: Maybe<ID_Input>;
  payload?: Maybe<PhaseFormsPayloadCreateOneInput>;
  result?: Maybe<String>;
}

export interface BranchCreateManyInput {
  create?: Maybe<BranchCreateInput[] | BranchCreateInput>;
  connect?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
}

export interface PhaseFormsPayloadCreateOneInput {
  create?: Maybe<PhaseFormsPayloadCreateInput>;
  connect?: Maybe<PhaseFormsPayloadWhereUniqueInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface PhaseFormsPayloadCreateInput {
  id?: Maybe<ID_Input>;
  phase: PhasePayloadCreateOneWithoutTasksInput;
  until?: Maybe<DateTimeInput>;
  required: Boolean;
  document: String;
  projectManager?: Maybe<UserCreateOneInput>;
  taskTitle: String;
}

export interface ProjectPhaseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectPhaseWhereInput>;
  AND?: Maybe<
    ProjectPhaseSubscriptionWhereInput[] | ProjectPhaseSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProjectPhaseSubscriptionWhereInput[] | ProjectPhaseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProjectPhaseSubscriptionWhereInput[] | ProjectPhaseSubscriptionWhereInput
  >;
}

export interface PhasePayloadCreateOneWithoutTasksInput {
  create?: Maybe<PhasePayloadCreateWithoutTasksInput>;
  connect?: Maybe<PhasePayloadWhereUniqueInput>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface PhasePayloadCreateWithoutTasksInput {
  id?: Maybe<ID_Input>;
  aktiv: Boolean;
}

export interface ProjectFormsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectFormsWhereInput>;
  AND?: Maybe<
    ProjectFormsSubscriptionWhereInput[] | ProjectFormsSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProjectFormsSubscriptionWhereInput[] | ProjectFormsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProjectFormsSubscriptionWhereInput[] | ProjectFormsSubscriptionWhereInput
  >;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PhasePayloadWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  aktiv?: Maybe<Boolean>;
  aktiv_not?: Maybe<Boolean>;
  tasks_every?: Maybe<PhaseFormsPayloadWhereInput>;
  tasks_some?: Maybe<PhaseFormsPayloadWhereInput>;
  tasks_none?: Maybe<PhaseFormsPayloadWhereInput>;
  AND?: Maybe<PhasePayloadWhereInput[] | PhasePayloadWhereInput>;
  OR?: Maybe<PhasePayloadWhereInput[] | PhasePayloadWhereInput>;
  NOT?: Maybe<PhasePayloadWhereInput[] | PhasePayloadWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  profileImage?: Maybe<String>;
  firstname: String;
  lastname: String;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  roles?: Maybe<UserCreaterolesInput>;
}

export interface BranchWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  buisness_every?: Maybe<BuisnessWhereInput>;
  buisness_some?: Maybe<BuisnessWhereInput>;
  buisness_none?: Maybe<BuisnessWhereInput>;
  address?: Maybe<AddressWhereInput>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  contacts_every?: Maybe<ContactWhereInput>;
  contacts_some?: Maybe<ContactWhereInput>;
  contacts_none?: Maybe<ContactWhereInput>;
  AND?: Maybe<BranchWhereInput[] | BranchWhereInput>;
  OR?: Maybe<BranchWhereInput[] | BranchWhereInput>;
  NOT?: Maybe<BranchWhereInput[] | BranchWhereInput>;
}

export interface UserCreaterolesInput {
  set?: Maybe<String[] | String>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface AnalyzeCustomerFormUpdateInput {
  payload?: Maybe<PhaseFormsPayloadUpdateOneInput>;
  result?: Maybe<String>;
}

export interface PhaseFormsPayloadSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhaseFormsPayloadWhereInput>;
  AND?: Maybe<
    | PhaseFormsPayloadSubscriptionWhereInput[]
    | PhaseFormsPayloadSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PhaseFormsPayloadSubscriptionWhereInput[]
    | PhaseFormsPayloadSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PhaseFormsPayloadSubscriptionWhereInput[]
    | PhaseFormsPayloadSubscriptionWhereInput
  >;
}

export interface PhaseFormsPayloadUpdateOneInput {
  create?: Maybe<PhaseFormsPayloadCreateInput>;
  update?: Maybe<PhaseFormsPayloadUpdateDataInput>;
  upsert?: Maybe<PhaseFormsPayloadUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PhaseFormsPayloadWhereUniqueInput>;
}

export interface PermissionActionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PermissionActionWhereInput>;
  AND?: Maybe<
    | PermissionActionSubscriptionWhereInput[]
    | PermissionActionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | PermissionActionSubscriptionWhereInput[]
    | PermissionActionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | PermissionActionSubscriptionWhereInput[]
    | PermissionActionSubscriptionWhereInput
  >;
}

export interface PhaseFormsPayloadUpdateDataInput {
  phase?: Maybe<PhasePayloadUpdateOneRequiredWithoutTasksInput>;
  until?: Maybe<DateTimeInput>;
  required?: Maybe<Boolean>;
  document?: Maybe<String>;
  projectManager?: Maybe<UserUpdateOneInput>;
  taskTitle?: Maybe<String>;
}

export interface MainProjectPhasesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MainProjectPhasesWhereInput>;
  AND?: Maybe<
    | MainProjectPhasesSubscriptionWhereInput[]
    | MainProjectPhasesSubscriptionWhereInput
  >;
  OR?: Maybe<
    | MainProjectPhasesSubscriptionWhereInput[]
    | MainProjectPhasesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | MainProjectPhasesSubscriptionWhereInput[]
    | MainProjectPhasesSubscriptionWhereInput
  >;
}

export interface PhasePayloadUpdateOneRequiredWithoutTasksInput {
  create?: Maybe<PhasePayloadCreateWithoutTasksInput>;
  update?: Maybe<PhasePayloadUpdateWithoutTasksDataInput>;
  upsert?: Maybe<PhasePayloadUpsertWithoutTasksInput>;
  connect?: Maybe<PhasePayloadWhereUniqueInput>;
}

export interface MainProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MainProjectWhereInput>;
  AND?: Maybe<
    MainProjectSubscriptionWhereInput[] | MainProjectSubscriptionWhereInput
  >;
  OR?: Maybe<
    MainProjectSubscriptionWhereInput[] | MainProjectSubscriptionWhereInput
  >;
  NOT?: Maybe<
    MainProjectSubscriptionWhereInput[] | MainProjectSubscriptionWhereInput
  >;
}

export interface PhasePayloadUpdateWithoutTasksDataInput {
  aktiv?: Maybe<Boolean>;
}

export interface CustomerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CustomerWhereInput>;
  AND?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
  OR?: Maybe<CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput>;
  NOT?: Maybe<
    CustomerSubscriptionWhereInput[] | CustomerSubscriptionWhereInput
  >;
}

export interface PhasePayloadUpsertWithoutTasksInput {
  update: PhasePayloadUpdateWithoutTasksDataInput;
  create: PhasePayloadCreateWithoutTasksInput;
}

export interface CriteriaCalculatorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CriteriaCalculatorWhereInput>;
  AND?: Maybe<
    | CriteriaCalculatorSubscriptionWhereInput[]
    | CriteriaCalculatorSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CriteriaCalculatorSubscriptionWhereInput[]
    | CriteriaCalculatorSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CriteriaCalculatorSubscriptionWhereInput[]
    | CriteriaCalculatorSubscriptionWhereInput
  >;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ContactSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ContactWhereInput>;
  AND?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  OR?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
  NOT?: Maybe<ContactSubscriptionWhereInput[] | ContactSubscriptionWhereInput>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  profileImage?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface BranchSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BranchWhereInput>;
  AND?: Maybe<BranchSubscriptionWhereInput[] | BranchSubscriptionWhereInput>;
  OR?: Maybe<BranchSubscriptionWhereInput[] | BranchSubscriptionWhereInput>;
  NOT?: Maybe<BranchSubscriptionWhereInput[] | BranchSubscriptionWhereInput>;
}

export interface UserUpdaterolesInput {
  set?: Maybe<String[] | String>;
}

export type CustomerWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ProjectManagerWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  manager?: Maybe<UserWhereInput>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProjectManagerWhereInput[] | ProjectManagerWhereInput>;
  OR?: Maybe<ProjectManagerWhereInput[] | ProjectManagerWhereInput>;
  NOT?: Maybe<ProjectManagerWhereInput[] | ProjectManagerWhereInput>;
}

export interface PhaseFormsPayloadUpsertNestedInput {
  update: PhaseFormsPayloadUpdateDataInput;
  create: PhaseFormsPayloadCreateInput;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  profileImage?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface AnalyzeCustomerFormUpdateManyMutationInput {
  result?: Maybe<String>;
}

export interface ProjectPhaseUpdateManyMutationInput {
  name?: Maybe<String>;
  status?: Maybe<Int>;
  roles?: Maybe<ProjectPhaseUpdaterolesInput>;
  users?: Maybe<ProjectPhaseUpdateusersInput>;
}

export interface BranchCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  type: String;
  buisness?: Maybe<BuisnessCreateManyInput>;
  address: AddressCreateOneInput;
  products?: Maybe<ProductCreateManyInput>;
  contacts?: Maybe<ContactCreateManyInput>;
}

export interface ProjectManagerUpdateManyMutationInput {
  order?: Maybe<Int>;
  notes?: Maybe<String>;
}

export interface BuisnessCreateManyInput {
  create?: Maybe<BuisnessCreateInput[] | BuisnessCreateInput>;
  connect?: Maybe<BuisnessWhereUniqueInput[] | BuisnessWhereUniqueInput>;
}

export type LeadWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BuisnessCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  shortDescription: String;
  longDescription: String;
}

export interface LeadWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  customerName?: Maybe<String>;
  customerName_not?: Maybe<String>;
  customerName_in?: Maybe<String[] | String>;
  customerName_not_in?: Maybe<String[] | String>;
  customerName_lt?: Maybe<String>;
  customerName_lte?: Maybe<String>;
  customerName_gt?: Maybe<String>;
  customerName_gte?: Maybe<String>;
  customerName_contains?: Maybe<String>;
  customerName_not_contains?: Maybe<String>;
  customerName_starts_with?: Maybe<String>;
  customerName_not_starts_with?: Maybe<String>;
  customerName_ends_with?: Maybe<String>;
  customerName_not_ends_with?: Maybe<String>;
  address?: Maybe<AddressWhereInput>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  products_every?: Maybe<ProductWhereInput>;
  products_some?: Maybe<ProductWhereInput>;
  products_none?: Maybe<ProductWhereInput>;
  AND?: Maybe<LeadWhereInput[] | LeadWhereInput>;
  OR?: Maybe<LeadWhereInput[] | LeadWhereInput>;
  NOT?: Maybe<LeadWhereInput[] | LeadWhereInput>;
}

export interface AddressCreateOneInput {
  create?: Maybe<AddressCreateInput>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface ProjectUpdateManyMutationInput {
  status?: Maybe<Int>;
  shortDescription?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface ProductCreateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
}

export interface MainProjectUpdateWithoutProjectsDataInput {
  customer?: Maybe<CustomerUpdateOneRequiredInput>;
  shortDescription?: Maybe<String>;
  status?: Maybe<Int>;
  projectManager?: Maybe<ProjectManagerUpdateManyInput>;
  notes?: Maybe<String>;
  phases?: Maybe<MainProjectPhasesUpdateOneRequiredInput>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  shortDescription: String;
  description: String;
}

export interface MainProjectUpdateOneRequiredWithoutProjectsInput {
  create?: Maybe<MainProjectCreateWithoutProjectsInput>;
  update?: Maybe<MainProjectUpdateWithoutProjectsDataInput>;
  upsert?: Maybe<MainProjectUpsertWithoutProjectsInput>;
  connect?: Maybe<MainProjectWhereUniqueInput>;
}

export interface ContactCreateManyInput {
  create?: Maybe<ContactCreateInput[] | ContactCreateInput>;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
}

export interface MainProjectWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  customer?: Maybe<CustomerWhereInput>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  projectManager_every?: Maybe<ProjectManagerWhereInput>;
  projectManager_some?: Maybe<ProjectManagerWhereInput>;
  projectManager_none?: Maybe<ProjectManagerWhereInput>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  projects_every?: Maybe<ProjectWhereInput>;
  projects_some?: Maybe<ProjectWhereInput>;
  projects_none?: Maybe<ProjectWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  phases?: Maybe<MainProjectPhasesWhereInput>;
  AND?: Maybe<MainProjectWhereInput[] | MainProjectWhereInput>;
  OR?: Maybe<MainProjectWhereInput[] | MainProjectWhereInput>;
  NOT?: Maybe<MainProjectWhereInput[] | MainProjectWhereInput>;
}

export interface ContactCreateInput {
  id?: Maybe<ID_Input>;
  profileImage?: Maybe<String>;
  email?: Maybe<String>;
  firstname: String;
  lastname?: Maybe<String>;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface ProjectPhaseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  forms?: Maybe<ProjectFormsWhereInput>;
  AND?: Maybe<ProjectPhaseWhereInput[] | ProjectPhaseWhereInput>;
  OR?: Maybe<ProjectPhaseWhereInput[] | ProjectPhaseWhereInput>;
  NOT?: Maybe<ProjectPhaseWhereInput[] | ProjectPhaseWhereInput>;
}

export interface BranchUpdateInput {
  name?: Maybe<String>;
  type?: Maybe<String>;
  buisness?: Maybe<BuisnessUpdateManyInput>;
  address?: Maybe<AddressUpdateOneRequiredInput>;
  products?: Maybe<ProductUpdateManyInput>;
  contacts?: Maybe<ContactUpdateManyInput>;
}

export interface ProjectUpdateInput {
  status?: Maybe<Int>;
  mainProject?: Maybe<MainProjectUpdateOneRequiredWithoutProjectsInput>;
  shortDescription?: Maybe<String>;
  notes?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredInput>;
  phases?: Maybe<ProjectPhaseUpdateManyInput>;
  projectManager?: Maybe<ProjectManagerUpdateManyInput>;
}

export interface BuisnessUpdateManyInput {
  create?: Maybe<BuisnessCreateInput[] | BuisnessCreateInput>;
  update?: Maybe<
    | BuisnessUpdateWithWhereUniqueNestedInput[]
    | BuisnessUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BuisnessUpsertWithWhereUniqueNestedInput[]
    | BuisnessUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BuisnessWhereUniqueInput[] | BuisnessWhereUniqueInput>;
  connect?: Maybe<BuisnessWhereUniqueInput[] | BuisnessWhereUniqueInput>;
  set?: Maybe<BuisnessWhereUniqueInput[] | BuisnessWhereUniqueInput>;
  disconnect?: Maybe<BuisnessWhereUniqueInput[] | BuisnessWhereUniqueInput>;
  deleteMany?: Maybe<BuisnessScalarWhereInput[] | BuisnessScalarWhereInput>;
  updateMany?: Maybe<
    | BuisnessUpdateManyWithWhereNestedInput[]
    | BuisnessUpdateManyWithWhereNestedInput
  >;
}

export interface MainProjectCreateOneWithoutProjectsInput {
  create?: Maybe<MainProjectCreateWithoutProjectsInput>;
  connect?: Maybe<MainProjectWhereUniqueInput>;
}

export interface BuisnessUpdateWithWhereUniqueNestedInput {
  where: BuisnessWhereUniqueInput;
  data: BuisnessUpdateDataInput;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  shortDescription?: Maybe<String>;
  description?: Maybe<String>;
}

export interface BuisnessUpdateDataInput {
  title?: Maybe<String>;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
}

export interface PhasePayloadUpdateManyMutationInput {
  aktiv?: Maybe<Boolean>;
}

export interface BuisnessUpsertWithWhereUniqueNestedInput {
  where: BuisnessWhereUniqueInput;
  update: BuisnessUpdateDataInput;
  create: BuisnessCreateInput;
}

export interface PhaseFormsPayloadUpdateManyMutationInput {
  until?: Maybe<DateTimeInput>;
  required?: Maybe<Boolean>;
  document?: Maybe<String>;
  taskTitle?: Maybe<String>;
}

export interface BuisnessScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  longDescription?: Maybe<String>;
  longDescription_not?: Maybe<String>;
  longDescription_in?: Maybe<String[] | String>;
  longDescription_not_in?: Maybe<String[] | String>;
  longDescription_lt?: Maybe<String>;
  longDescription_lte?: Maybe<String>;
  longDescription_gt?: Maybe<String>;
  longDescription_gte?: Maybe<String>;
  longDescription_contains?: Maybe<String>;
  longDescription_not_contains?: Maybe<String>;
  longDescription_starts_with?: Maybe<String>;
  longDescription_not_starts_with?: Maybe<String>;
  longDescription_ends_with?: Maybe<String>;
  longDescription_not_ends_with?: Maybe<String>;
  AND?: Maybe<BuisnessScalarWhereInput[] | BuisnessScalarWhereInput>;
  OR?: Maybe<BuisnessScalarWhereInput[] | BuisnessScalarWhereInput>;
  NOT?: Maybe<BuisnessScalarWhereInput[] | BuisnessScalarWhereInput>;
}

export type MainProjectPhasesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BuisnessUpdateManyWithWhereNestedInput {
  where: BuisnessScalarWhereInput;
  data: BuisnessUpdateManyDataInput;
}

export interface PermissionActionUpdateInput {
  type?: Maybe<String>;
  users?: Maybe<UserUpdateManyInput>;
  roles?: Maybe<PermissionActionUpdaterolesInput>;
}

export interface BuisnessUpdateManyDataInput {
  title?: Maybe<String>;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
}

export interface PermissionActionUpdateManyDataInput {
  type?: Maybe<String>;
  roles?: Maybe<PermissionActionUpdaterolesInput>;
}

export interface AddressUpdateOneRequiredInput {
  create?: Maybe<AddressCreateInput>;
  update?: Maybe<AddressUpdateDataInput>;
  upsert?: Maybe<AddressUpsertNestedInput>;
  connect?: Maybe<AddressWhereUniqueInput>;
}

export interface PermissionActionUpdateManyWithWhereNestedInput {
  where: PermissionActionScalarWhereInput;
  data: PermissionActionUpdateManyDataInput;
}

export interface AddressUpdateDataInput {
  postalCode?: Maybe<String>;
  city?: Maybe<String>;
  street?: Maybe<String>;
  country?: Maybe<String>;
}

export interface PermissionActionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    PermissionActionScalarWhereInput[] | PermissionActionScalarWhereInput
  >;
  OR?: Maybe<
    PermissionActionScalarWhereInput[] | PermissionActionScalarWhereInput
  >;
  NOT?: Maybe<
    PermissionActionScalarWhereInput[] | PermissionActionScalarWhereInput
  >;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface PermissionActionUpdaterolesInput {
  set?: Maybe<String[] | String>;
}

export interface ProductUpdateManyInput {
  create?: Maybe<ProductCreateInput[] | ProductCreateInput>;
  update?: Maybe<
    | ProductUpdateWithWhereUniqueNestedInput[]
    | ProductUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductUpsertWithWhereUniqueNestedInput[]
    | ProductUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  connect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  set?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  disconnect?: Maybe<ProductWhereUniqueInput[] | ProductWhereUniqueInput>;
  deleteMany?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  updateMany?: Maybe<
    | ProductUpdateManyWithWhereNestedInput[]
    | ProductUpdateManyWithWhereNestedInput
  >;
}

export interface AddressWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  postalCode?: Maybe<String>;
  postalCode_not?: Maybe<String>;
  postalCode_in?: Maybe<String[] | String>;
  postalCode_not_in?: Maybe<String[] | String>;
  postalCode_lt?: Maybe<String>;
  postalCode_lte?: Maybe<String>;
  postalCode_gt?: Maybe<String>;
  postalCode_gte?: Maybe<String>;
  postalCode_contains?: Maybe<String>;
  postalCode_not_contains?: Maybe<String>;
  postalCode_starts_with?: Maybe<String>;
  postalCode_not_starts_with?: Maybe<String>;
  postalCode_ends_with?: Maybe<String>;
  postalCode_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  AND?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  OR?: Maybe<AddressWhereInput[] | AddressWhereInput>;
  NOT?: Maybe<AddressWhereInput[] | AddressWhereInput>;
}

export interface ProductUpdateWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  data: ProductUpdateDataInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface ProductUpdateDataInput {
  name?: Maybe<String>;
  shortDescription?: Maybe<String>;
  description?: Maybe<String>;
}

export type PermissionActionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductUpsertWithWhereUniqueNestedInput {
  where: ProductWhereUniqueInput;
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface ProductScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  OR?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
  NOT?: Maybe<ProductScalarWhereInput[] | ProductScalarWhereInput>;
}

export type PhaseFormsPayloadWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductUpdateManyWithWhereNestedInput {
  where: ProductScalarWhereInput;
  data: ProductUpdateManyDataInput;
}

export interface PermissionActionUpdateWithWhereUniqueNestedInput {
  where: PermissionActionWhereUniqueInput;
  data: PermissionActionUpdateDataInput;
}

export interface ProductUpdateManyDataInput {
  name?: Maybe<String>;
  shortDescription?: Maybe<String>;
  description?: Maybe<String>;
}

export type PhasePayloadWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContactUpdateManyInput {
  create?: Maybe<ContactCreateInput[] | ContactCreateInput>;
  update?: Maybe<
    | ContactUpdateWithWhereUniqueNestedInput[]
    | ContactUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ContactUpsertWithWhereUniqueNestedInput[]
    | ContactUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  connect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  set?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  disconnect?: Maybe<ContactWhereUniqueInput[] | ContactWhereUniqueInput>;
  deleteMany?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  updateMany?: Maybe<
    | ContactUpdateManyWithWhereNestedInput[]
    | ContactUpdateManyWithWhereNestedInput
  >;
}

export interface PermissionActionCreaterolesInput {
  set?: Maybe<String[] | String>;
}

export interface ContactUpdateWithWhereUniqueNestedInput {
  where: ContactWhereUniqueInput;
  data: ContactUpdateDataInput;
}

export interface PermissionActionCreateInput {
  id?: Maybe<ID_Input>;
  type?: Maybe<String>;
  users?: Maybe<UserCreateManyInput>;
  roles?: Maybe<PermissionActionCreaterolesInput>;
}

export interface ContactUpdateDataInput {
  profileImage?: Maybe<String>;
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface PermissionActionCreateManyInput {
  create?: Maybe<PermissionActionCreateInput[] | PermissionActionCreateInput>;
  connect?: Maybe<
    PermissionActionWhereUniqueInput[] | PermissionActionWhereUniqueInput
  >;
}

export interface ProjectPhaseUpdateManyDataInput {
  name?: Maybe<String>;
  status?: Maybe<Int>;
  roles?: Maybe<ProjectPhaseUpdaterolesInput>;
  users?: Maybe<ProjectPhaseUpdateusersInput>;
}

export interface MainProjectPhasesUpdateInput {
  salesphase?: Maybe<PhasePayloadUpdateOneRequiredInput>;
}

export interface ContactScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  profileImage?: Maybe<String>;
  profileImage_not?: Maybe<String>;
  profileImage_in?: Maybe<String[] | String>;
  profileImage_not_in?: Maybe<String[] | String>;
  profileImage_lt?: Maybe<String>;
  profileImage_lte?: Maybe<String>;
  profileImage_gt?: Maybe<String>;
  profileImage_gte?: Maybe<String>;
  profileImage_contains?: Maybe<String>;
  profileImage_not_contains?: Maybe<String>;
  profileImage_starts_with?: Maybe<String>;
  profileImage_not_starts_with?: Maybe<String>;
  profileImage_ends_with?: Maybe<String>;
  profileImage_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  telephone?: Maybe<String>;
  telephone_not?: Maybe<String>;
  telephone_in?: Maybe<String[] | String>;
  telephone_not_in?: Maybe<String[] | String>;
  telephone_lt?: Maybe<String>;
  telephone_lte?: Maybe<String>;
  telephone_gt?: Maybe<String>;
  telephone_gte?: Maybe<String>;
  telephone_contains?: Maybe<String>;
  telephone_not_contains?: Maybe<String>;
  telephone_starts_with?: Maybe<String>;
  telephone_not_starts_with?: Maybe<String>;
  telephone_ends_with?: Maybe<String>;
  telephone_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  OR?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
  NOT?: Maybe<ContactScalarWhereInput[] | ContactScalarWhereInput>;
}

export interface MainProjectUpdateManyMutationInput {
  shortDescription?: Maybe<String>;
  status?: Maybe<Int>;
  notes?: Maybe<String>;
}

export interface ContactUpdateManyWithWhereNestedInput {
  where: ContactScalarWhereInput;
  data: ContactUpdateManyDataInput;
}

export interface PhasePayloadUpsertNestedInput {
  update: PhasePayloadUpdateDataInput;
  create: PhasePayloadCreateInput;
}

export interface ContactUpdateManyDataInput {
  profileImage?: Maybe<String>;
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface PhaseFormsPayloadUpdateManyDataInput {
  until?: Maybe<DateTimeInput>;
  required?: Maybe<Boolean>;
  document?: Maybe<String>;
  taskTitle?: Maybe<String>;
}

export interface BranchUpdateManyMutationInput {
  name?: Maybe<String>;
  type?: Maybe<String>;
}

export interface PhaseFormsPayloadScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  until?: Maybe<DateTimeInput>;
  until_not?: Maybe<DateTimeInput>;
  until_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  until_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  until_lt?: Maybe<DateTimeInput>;
  until_lte?: Maybe<DateTimeInput>;
  until_gt?: Maybe<DateTimeInput>;
  until_gte?: Maybe<DateTimeInput>;
  required?: Maybe<Boolean>;
  required_not?: Maybe<Boolean>;
  document?: Maybe<String>;
  document_not?: Maybe<String>;
  document_in?: Maybe<String[] | String>;
  document_not_in?: Maybe<String[] | String>;
  document_lt?: Maybe<String>;
  document_lte?: Maybe<String>;
  document_gt?: Maybe<String>;
  document_gte?: Maybe<String>;
  document_contains?: Maybe<String>;
  document_not_contains?: Maybe<String>;
  document_starts_with?: Maybe<String>;
  document_not_starts_with?: Maybe<String>;
  document_ends_with?: Maybe<String>;
  document_not_ends_with?: Maybe<String>;
  taskTitle?: Maybe<String>;
  taskTitle_not?: Maybe<String>;
  taskTitle_in?: Maybe<String[] | String>;
  taskTitle_not_in?: Maybe<String[] | String>;
  taskTitle_lt?: Maybe<String>;
  taskTitle_lte?: Maybe<String>;
  taskTitle_gt?: Maybe<String>;
  taskTitle_gte?: Maybe<String>;
  taskTitle_contains?: Maybe<String>;
  taskTitle_not_contains?: Maybe<String>;
  taskTitle_starts_with?: Maybe<String>;
  taskTitle_not_starts_with?: Maybe<String>;
  taskTitle_ends_with?: Maybe<String>;
  taskTitle_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    PhaseFormsPayloadScalarWhereInput[] | PhaseFormsPayloadScalarWhereInput
  >;
  OR?: Maybe<
    PhaseFormsPayloadScalarWhereInput[] | PhaseFormsPayloadScalarWhereInput
  >;
  NOT?: Maybe<
    PhaseFormsPayloadScalarWhereInput[] | PhaseFormsPayloadScalarWhereInput
  >;
}

export interface BuisnessUpdateInput {
  title?: Maybe<String>;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
}

export type ProjectManagerWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BuisnessUpdateManyMutationInput {
  title?: Maybe<String>;
  shortDescription?: Maybe<String>;
  longDescription?: Maybe<String>;
}

export interface PhaseFormsPayloadUpdateWithWhereUniqueWithoutPhaseInput {
  where: PhaseFormsPayloadWhereUniqueInput;
  data: PhaseFormsPayloadUpdateWithoutPhaseDataInput;
}

export interface ContactUpdateInput {
  profileImage?: Maybe<String>;
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  notes?: Maybe<String>;
}

export type ProjectPhaseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ContactUpdateManyMutationInput {
  profileImage?: Maybe<String>;
  email?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface PhasePayloadUpdateOneRequiredInput {
  create?: Maybe<PhasePayloadCreateInput>;
  update?: Maybe<PhasePayloadUpdateDataInput>;
  upsert?: Maybe<PhasePayloadUpsertNestedInput>;
  connect?: Maybe<PhasePayloadWhereUniqueInput>;
}

export interface CriteriaCalculatorCreateInput {
  id?: Maybe<ID_Input>;
  status: Int;
  required: Boolean;
  milestone: Boolean;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface CriteriaCalculatorUpdateInput {
  status?: Maybe<Int>;
  required?: Maybe<Boolean>;
  milestone?: Maybe<Boolean>;
}

export interface ProjectUpdateManyDataInput {
  status?: Maybe<Int>;
  shortDescription?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface CriteriaCalculatorUpdateManyMutationInput {
  status?: Maybe<Int>;
  required?: Maybe<Boolean>;
  milestone?: Maybe<Boolean>;
}

export interface AddressUpdateInput {
  postalCode?: Maybe<String>;
  city?: Maybe<String>;
  street?: Maybe<String>;
  country?: Maybe<String>;
}

export interface ProjectPhaseUpdateManyWithWhereNestedInput {
  where: ProjectPhaseScalarWhereInput;
  data: ProjectPhaseUpdateManyDataInput;
}

export interface ProjectScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  OR?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  NOT?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
}

export interface ProjectPhaseScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  AND?: Maybe<ProjectPhaseScalarWhereInput[] | ProjectPhaseScalarWhereInput>;
  OR?: Maybe<ProjectPhaseScalarWhereInput[] | ProjectPhaseScalarWhereInput>;
  NOT?: Maybe<ProjectPhaseScalarWhereInput[] | ProjectPhaseScalarWhereInput>;
}

export interface BuisnessWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  longDescription?: Maybe<String>;
  longDescription_not?: Maybe<String>;
  longDescription_in?: Maybe<String[] | String>;
  longDescription_not_in?: Maybe<String[] | String>;
  longDescription_lt?: Maybe<String>;
  longDescription_lte?: Maybe<String>;
  longDescription_gt?: Maybe<String>;
  longDescription_gte?: Maybe<String>;
  longDescription_contains?: Maybe<String>;
  longDescription_not_contains?: Maybe<String>;
  longDescription_starts_with?: Maybe<String>;
  longDescription_not_starts_with?: Maybe<String>;
  longDescription_ends_with?: Maybe<String>;
  longDescription_not_ends_with?: Maybe<String>;
  AND?: Maybe<BuisnessWhereInput[] | BuisnessWhereInput>;
  OR?: Maybe<BuisnessWhereInput[] | BuisnessWhereInput>;
  NOT?: Maybe<BuisnessWhereInput[] | BuisnessWhereInput>;
}

export interface ProjectManagerCreateManyInput {
  create?: Maybe<ProjectManagerCreateInput[] | ProjectManagerCreateInput>;
  connect?: Maybe<
    ProjectManagerWhereUniqueInput[] | ProjectManagerWhereUniqueInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  profileImage?: Maybe<String>;
  profileImage_not?: Maybe<String>;
  profileImage_in?: Maybe<String[] | String>;
  profileImage_not_in?: Maybe<String[] | String>;
  profileImage_lt?: Maybe<String>;
  profileImage_lte?: Maybe<String>;
  profileImage_gt?: Maybe<String>;
  profileImage_gte?: Maybe<String>;
  profileImage_contains?: Maybe<String>;
  profileImage_not_contains?: Maybe<String>;
  profileImage_starts_with?: Maybe<String>;
  profileImage_not_starts_with?: Maybe<String>;
  profileImage_ends_with?: Maybe<String>;
  profileImage_not_ends_with?: Maybe<String>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  telephone?: Maybe<String>;
  telephone_not?: Maybe<String>;
  telephone_in?: Maybe<String[] | String>;
  telephone_not_in?: Maybe<String[] | String>;
  telephone_lt?: Maybe<String>;
  telephone_lte?: Maybe<String>;
  telephone_gt?: Maybe<String>;
  telephone_gte?: Maybe<String>;
  telephone_contains?: Maybe<String>;
  telephone_not_contains?: Maybe<String>;
  telephone_starts_with?: Maybe<String>;
  telephone_not_starts_with?: Maybe<String>;
  telephone_ends_with?: Maybe<String>;
  telephone_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ProjectManagerCreateInput {
  id?: Maybe<ID_Input>;
  order: Int;
  manager: UserCreateOneInput;
  notes?: Maybe<String>;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectWhereInput>;
  AND?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  OR?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  NOT?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
}

export interface CustomerUpdateInput {
  logo?: Maybe<String>;
  name?: Maybe<String>;
  branch?: Maybe<BranchUpdateManyInput>;
  classification?: Maybe<String>;
  projectManager?: Maybe<ProjectManagerUpdateManyInput>;
  notes?: Maybe<String>;
}

export interface PhasePayloadSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PhasePayloadWhereInput>;
  AND?: Maybe<
    PhasePayloadSubscriptionWhereInput[] | PhasePayloadSubscriptionWhereInput
  >;
  OR?: Maybe<
    PhasePayloadSubscriptionWhereInput[] | PhasePayloadSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PhasePayloadSubscriptionWhereInput[] | PhasePayloadSubscriptionWhereInput
  >;
}

export interface BranchUpdateManyInput {
  create?: Maybe<BranchCreateInput[] | BranchCreateInput>;
  update?: Maybe<
    | BranchUpdateWithWhereUniqueNestedInput[]
    | BranchUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | BranchUpsertWithWhereUniqueNestedInput[]
    | BranchUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
  connect?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
  set?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
  disconnect?: Maybe<BranchWhereUniqueInput[] | BranchWhereUniqueInput>;
  deleteMany?: Maybe<BranchScalarWhereInput[] | BranchScalarWhereInput>;
  updateMany?: Maybe<
    | BranchUpdateManyWithWhereNestedInput[]
    | BranchUpdateManyWithWhereNestedInput
  >;
}

export interface PermissionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PermissionWhereInput>;
  AND?: Maybe<
    PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput
  >;
  OR?: Maybe<
    PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput
  >;
}

export interface BranchUpdateWithWhereUniqueNestedInput {
  where: BranchWhereUniqueInput;
  data: BranchUpdateDataInput;
}

export interface LeadSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LeadWhereInput>;
  AND?: Maybe<LeadSubscriptionWhereInput[] | LeadSubscriptionWhereInput>;
  OR?: Maybe<LeadSubscriptionWhereInput[] | LeadSubscriptionWhereInput>;
  NOT?: Maybe<LeadSubscriptionWhereInput[] | LeadSubscriptionWhereInput>;
}

export interface BranchUpdateDataInput {
  name?: Maybe<String>;
  type?: Maybe<String>;
  buisness?: Maybe<BuisnessUpdateManyInput>;
  address?: Maybe<AddressUpdateOneRequiredInput>;
  products?: Maybe<ProductUpdateManyInput>;
  contacts?: Maybe<ContactUpdateManyInput>;
}

export interface CriteriaCalculatorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  required?: Maybe<Boolean>;
  required_not?: Maybe<Boolean>;
  milestone?: Maybe<Boolean>;
  milestone_not?: Maybe<Boolean>;
  AND?: Maybe<CriteriaCalculatorWhereInput[] | CriteriaCalculatorWhereInput>;
  OR?: Maybe<CriteriaCalculatorWhereInput[] | CriteriaCalculatorWhereInput>;
  NOT?: Maybe<CriteriaCalculatorWhereInput[] | CriteriaCalculatorWhereInput>;
}

export interface BranchUpsertWithWhereUniqueNestedInput {
  where: BranchWhereUniqueInput;
  update: BranchUpdateDataInput;
  create: BranchCreateInput;
}

export interface AnalyzeCustomerFormSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AnalyzeCustomerFormWhereInput>;
  AND?: Maybe<
    | AnalyzeCustomerFormSubscriptionWhereInput[]
    | AnalyzeCustomerFormSubscriptionWhereInput
  >;
  OR?: Maybe<
    | AnalyzeCustomerFormSubscriptionWhereInput[]
    | AnalyzeCustomerFormSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | AnalyzeCustomerFormSubscriptionWhereInput[]
    | AnalyzeCustomerFormSubscriptionWhereInput
  >;
}

export interface BranchScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<BranchScalarWhereInput[] | BranchScalarWhereInput>;
  OR?: Maybe<BranchScalarWhereInput[] | BranchScalarWhereInput>;
  NOT?: Maybe<BranchScalarWhereInput[] | BranchScalarWhereInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  profileImage?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface BranchUpdateManyWithWhereNestedInput {
  where: BranchScalarWhereInput;
  data: BranchUpdateManyDataInput;
}

export interface ProjectPhaseUpdateInput {
  name?: Maybe<String>;
  status?: Maybe<Int>;
  roles?: Maybe<ProjectPhaseUpdaterolesInput>;
  users?: Maybe<ProjectPhaseUpdateusersInput>;
  forms?: Maybe<ProjectFormsUpdateOneInput>;
}

export interface BranchUpdateManyDataInput {
  name?: Maybe<String>;
  type?: Maybe<String>;
}

export interface ProjectFormsUpdateInput {
  criteriaCalculator?: Maybe<CriteriaCalculatorUpdateOneInput>;
}

export interface ProjectManagerUpdateManyInput {
  create?: Maybe<ProjectManagerCreateInput[] | ProjectManagerCreateInput>;
  update?: Maybe<
    | ProjectManagerUpdateWithWhereUniqueNestedInput[]
    | ProjectManagerUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProjectManagerUpsertWithWhereUniqueNestedInput[]
    | ProjectManagerUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    ProjectManagerWhereUniqueInput[] | ProjectManagerWhereUniqueInput
  >;
  connect?: Maybe<
    ProjectManagerWhereUniqueInput[] | ProjectManagerWhereUniqueInput
  >;
  set?: Maybe<
    ProjectManagerWhereUniqueInput[] | ProjectManagerWhereUniqueInput
  >;
  disconnect?: Maybe<
    ProjectManagerWhereUniqueInput[] | ProjectManagerWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ProjectManagerScalarWhereInput[] | ProjectManagerScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProjectManagerUpdateManyWithWhereNestedInput[]
    | ProjectManagerUpdateManyWithWhereNestedInput
  >;
}

export interface MainProjectUpsertWithoutProjectsInput {
  update: MainProjectUpdateWithoutProjectsDataInput;
  create: MainProjectCreateWithoutProjectsInput;
}

export interface ProjectManagerUpdateWithWhereUniqueNestedInput {
  where: ProjectManagerWhereUniqueInput;
  data: ProjectManagerUpdateDataInput;
}

export interface ProjectWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  mainProject?: Maybe<MainProjectWhereInput>;
  shortDescription?: Maybe<String>;
  shortDescription_not?: Maybe<String>;
  shortDescription_in?: Maybe<String[] | String>;
  shortDescription_not_in?: Maybe<String[] | String>;
  shortDescription_lt?: Maybe<String>;
  shortDescription_lte?: Maybe<String>;
  shortDescription_gt?: Maybe<String>;
  shortDescription_gte?: Maybe<String>;
  shortDescription_contains?: Maybe<String>;
  shortDescription_not_contains?: Maybe<String>;
  shortDescription_starts_with?: Maybe<String>;
  shortDescription_not_starts_with?: Maybe<String>;
  shortDescription_ends_with?: Maybe<String>;
  shortDescription_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  product?: Maybe<ProductWhereInput>;
  phases_every?: Maybe<ProjectPhaseWhereInput>;
  phases_some?: Maybe<ProjectPhaseWhereInput>;
  phases_none?: Maybe<ProjectPhaseWhereInput>;
  projectManager_every?: Maybe<ProjectManagerWhereInput>;
  projectManager_some?: Maybe<ProjectManagerWhereInput>;
  projectManager_none?: Maybe<ProjectManagerWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  OR?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  NOT?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
}

export interface ProjectManagerUpdateDataInput {
  order?: Maybe<Int>;
  manager?: Maybe<UserUpdateOneRequiredInput>;
  notes?: Maybe<String>;
}

export interface ProjectFormsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  criteriaCalculator?: Maybe<CriteriaCalculatorWhereInput>;
  AND?: Maybe<ProjectFormsWhereInput[] | ProjectFormsWhereInput>;
  OR?: Maybe<ProjectFormsWhereInput[] | ProjectFormsWhereInput>;
  NOT?: Maybe<ProjectFormsWhereInput[] | ProjectFormsWhereInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ProjectCreateInput {
  id?: Maybe<Int>;
  status: Int;
  mainProject: MainProjectCreateOneWithoutProjectsInput;
  shortDescription: String;
  notes?: Maybe<String>;
  product: ProductCreateOneInput;
  phases?: Maybe<ProjectPhaseCreateManyInput>;
  projectManager?: Maybe<ProjectManagerCreateManyInput>;
}

export interface ProjectManagerUpsertWithWhereUniqueNestedInput {
  where: ProjectManagerWhereUniqueInput;
  update: ProjectManagerUpdateDataInput;
  create: ProjectManagerCreateInput;
}

export interface PhasePayloadUpdateInput {
  aktiv?: Maybe<Boolean>;
  tasks?: Maybe<PhaseFormsPayloadUpdateManyWithoutPhaseInput>;
}

export interface ProjectManagerScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    ProjectManagerScalarWhereInput[] | ProjectManagerScalarWhereInput
  >;
  OR?: Maybe<ProjectManagerScalarWhereInput[] | ProjectManagerScalarWhereInput>;
  NOT?: Maybe<
    ProjectManagerScalarWhereInput[] | ProjectManagerScalarWhereInput
  >;
}

export interface PermissionActionUpdateManyMutationInput {
  type?: Maybe<String>;
  roles?: Maybe<PermissionActionUpdaterolesInput>;
}

export interface ProjectManagerUpdateManyWithWhereNestedInput {
  where: ProjectManagerScalarWhereInput;
  data: ProjectManagerUpdateManyDataInput;
}

export type PermissionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  buisnessObj?: Maybe<String>;
}>;

export interface ProjectManagerUpdateManyDataInput {
  order?: Maybe<Int>;
  notes?: Maybe<String>;
}

export interface PermissionActionUpsertWithWhereUniqueNestedInput {
  where: PermissionActionWhereUniqueInput;
  update: PermissionActionUpdateDataInput;
  create: PermissionActionCreateInput;
}

export interface CustomerUpdateManyMutationInput {
  logo?: Maybe<String>;
  name?: Maybe<String>;
  classification?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface UserUpdateManyDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  profileImage?: Maybe<String>;
  firstname?: Maybe<String>;
  lastname?: Maybe<String>;
  nickname?: Maybe<String>;
  telephone?: Maybe<String>;
  mobile?: Maybe<String>;
  position?: Maybe<String>;
  roles?: Maybe<UserUpdaterolesInput>;
}

export interface LeadCreateInput {
  id?: Maybe<ID_Input>;
  customerName: String;
  address: AddressCreateOneInput;
  notes?: Maybe<String>;
  products?: Maybe<ProductCreateManyInput>;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface LeadUpdateInput {
  customerName?: Maybe<String>;
  address?: Maybe<AddressUpdateOneRequiredInput>;
  notes?: Maybe<String>;
  products?: Maybe<ProductUpdateManyInput>;
}

export interface PermissionActionUpdateDataInput {
  type?: Maybe<String>;
  users?: Maybe<UserUpdateManyInput>;
  roles?: Maybe<PermissionActionUpdaterolesInput>;
}

export interface LeadUpdateManyMutationInput {
  customerName?: Maybe<String>;
  notes?: Maybe<String>;
}

export interface PermissionUpdateInput {
  buisnessObj?: Maybe<String>;
  actions?: Maybe<PermissionActionUpdateManyInput>;
}

export interface MainProjectCreateInput {
  id?: Maybe<Int>;
  customer: CustomerCreateOneInput;
  shortDescription: String;
  status: Int;
  projectManager?: Maybe<ProjectManagerCreateManyInput>;
  notes?: Maybe<String>;
  projects?: Maybe<ProjectCreateManyWithoutMainProjectInput>;
  phases: MainProjectPhasesCreateOneInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CustomerCreateOneInput {
  create?: Maybe<CustomerCreateInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ProjectCreateManyWithoutMainProjectInput {
  create?: Maybe<
    | ProjectCreateWithoutMainProjectInput[]
    | ProjectCreateWithoutMainProjectInput
  >;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
}

export type ProjectFormsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectCreateWithoutMainProjectInput {
  id?: Maybe<Int>;
  status: Int;
  shortDescription: String;
  notes?: Maybe<String>;
  product: ProductCreateOneInput;
  phases?: Maybe<ProjectPhaseCreateManyInput>;
  projectManager?: Maybe<ProjectManagerCreateManyInput>;
}

export interface PhaseFormsPayloadUpsertWithWhereUniqueWithoutPhaseInput {
  where: PhaseFormsPayloadWhereUniqueInput;
  update: PhaseFormsPayloadUpdateWithoutPhaseDataInput;
  create: PhaseFormsPayloadCreateWithoutPhaseInput;
}

export interface ProductCreateOneInput {
  create?: Maybe<ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface PhaseFormsPayloadUpdateManyWithoutPhaseInput {
  create?: Maybe<
    | PhaseFormsPayloadCreateWithoutPhaseInput[]
    | PhaseFormsPayloadCreateWithoutPhaseInput
  >;
  delete?: Maybe<
    PhaseFormsPayloadWhereUniqueInput[] | PhaseFormsPayloadWhereUniqueInput
  >;
  connect?: Maybe<
    PhaseFormsPayloadWhereUniqueInput[] | PhaseFormsPayloadWhereUniqueInput
  >;
  set?: Maybe<
    PhaseFormsPayloadWhereUniqueInput[] | PhaseFormsPayloadWhereUniqueInput
  >;
  disconnect?: Maybe<
    PhaseFormsPayloadWhereUniqueInput[] | PhaseFormsPayloadWhereUniqueInput
  >;
  update?: Maybe<
    | PhaseFormsPayloadUpdateWithWhereUniqueWithoutPhaseInput[]
    | PhaseFormsPayloadUpdateWithWhereUniqueWithoutPhaseInput
  >;
  upsert?: Maybe<
    | PhaseFormsPayloadUpsertWithWhereUniqueWithoutPhaseInput[]
    | PhaseFormsPayloadUpsertWithWhereUniqueWithoutPhaseInput
  >;
  deleteMany?: Maybe<
    PhaseFormsPayloadScalarWhereInput[] | PhaseFormsPayloadScalarWhereInput
  >;
  updateMany?: Maybe<
    | PhaseFormsPayloadUpdateManyWithWhereNestedInput[]
    | PhaseFormsPayloadUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectPhaseCreateManyInput {
  create?: Maybe<ProjectPhaseCreateInput[] | ProjectPhaseCreateInput>;
  connect?: Maybe<
    ProjectPhaseWhereUniqueInput[] | ProjectPhaseWhereUniqueInput
  >;
}

export interface MainProjectPhasesUpdateDataInput {
  salesphase?: Maybe<PhasePayloadUpdateOneRequiredInput>;
}

export interface ProjectPhaseCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  status?: Maybe<Int>;
  roles?: Maybe<ProjectPhaseCreaterolesInput>;
  users?: Maybe<ProjectPhaseCreateusersInput>;
  forms?: Maybe<ProjectFormsCreateOneInput>;
}

export interface ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput;
  data: ProjectUpdateManyDataInput;
}

export interface ProjectPhaseCreaterolesInput {
  set?: Maybe<String[] | String>;
}

export interface AddressUpdateManyMutationInput {
  postalCode?: Maybe<String>;
  city?: Maybe<String>;
  street?: Maybe<String>;
  country?: Maybe<String>;
}

export interface ProjectPhaseCreateusersInput {
  set?: Maybe<String[] | String>;
}

export interface ProjectManagerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectManagerWhereInput>;
  AND?: Maybe<
    | ProjectManagerSubscriptionWhereInput[]
    | ProjectManagerSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProjectManagerSubscriptionWhereInput[]
    | ProjectManagerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProjectManagerSubscriptionWhereInput[]
    | ProjectManagerSubscriptionWhereInput
  >;
}

export interface ProjectFormsCreateOneInput {
  create?: Maybe<ProjectFormsCreateInput>;
  connect?: Maybe<ProjectFormsWhereUniqueInput>;
}

export interface PhaseFormsPayloadWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  phase?: Maybe<PhasePayloadWhereInput>;
  until?: Maybe<DateTimeInput>;
  until_not?: Maybe<DateTimeInput>;
  until_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  until_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  until_lt?: Maybe<DateTimeInput>;
  until_lte?: Maybe<DateTimeInput>;
  until_gt?: Maybe<DateTimeInput>;
  until_gte?: Maybe<DateTimeInput>;
  required?: Maybe<Boolean>;
  required_not?: Maybe<Boolean>;
  document?: Maybe<String>;
  document_not?: Maybe<String>;
  document_in?: Maybe<String[] | String>;
  document_not_in?: Maybe<String[] | String>;
  document_lt?: Maybe<String>;
  document_lte?: Maybe<String>;
  document_gt?: Maybe<String>;
  document_gte?: Maybe<String>;
  document_contains?: Maybe<String>;
  document_not_contains?: Maybe<String>;
  document_starts_with?: Maybe<String>;
  document_not_starts_with?: Maybe<String>;
  document_ends_with?: Maybe<String>;
  document_not_ends_with?: Maybe<String>;
  projectManager?: Maybe<UserWhereInput>;
  taskTitle?: Maybe<String>;
  taskTitle_not?: Maybe<String>;
  taskTitle_in?: Maybe<String[] | String>;
  taskTitle_not_in?: Maybe<String[] | String>;
  taskTitle_lt?: Maybe<String>;
  taskTitle_lte?: Maybe<String>;
  taskTitle_gt?: Maybe<String>;
  taskTitle_gte?: Maybe<String>;
  taskTitle_contains?: Maybe<String>;
  taskTitle_not_contains?: Maybe<String>;
  taskTitle_starts_with?: Maybe<String>;
  taskTitle_not_starts_with?: Maybe<String>;
  taskTitle_ends_with?: Maybe<String>;
  taskTitle_not_ends_with?: Maybe<String>;
  AND?: Maybe<PhaseFormsPayloadWhereInput[] | PhaseFormsPayloadWhereInput>;
  OR?: Maybe<PhaseFormsPayloadWhereInput[] | PhaseFormsPayloadWhereInput>;
  NOT?: Maybe<PhaseFormsPayloadWhereInput[] | PhaseFormsPayloadWhereInput>;
}

export interface ProjectFormsCreateInput {
  id?: Maybe<ID_Input>;
  criteriaCalculator?: Maybe<CriteriaCalculatorCreateOneInput>;
}

export type ContactWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CriteriaCalculatorCreateOneInput {
  create?: Maybe<CriteriaCalculatorCreateInput>;
  connect?: Maybe<CriteriaCalculatorWhereUniqueInput>;
}

export interface BuisnessSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BuisnessWhereInput>;
  AND?: Maybe<
    BuisnessSubscriptionWhereInput[] | BuisnessSubscriptionWhereInput
  >;
  OR?: Maybe<BuisnessSubscriptionWhereInput[] | BuisnessSubscriptionWhereInput>;
  NOT?: Maybe<
    BuisnessSubscriptionWhereInput[] | BuisnessSubscriptionWhereInput
  >;
}

export interface MainProjectPhasesCreateOneInput {
  create?: Maybe<MainProjectPhasesCreateInput>;
  connect?: Maybe<MainProjectPhasesWhereUniqueInput>;
}

export interface CustomerWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  branch_every?: Maybe<BranchWhereInput>;
  branch_some?: Maybe<BranchWhereInput>;
  branch_none?: Maybe<BranchWhereInput>;
  classification?: Maybe<String>;
  classification_not?: Maybe<String>;
  classification_in?: Maybe<String[] | String>;
  classification_not_in?: Maybe<String[] | String>;
  classification_lt?: Maybe<String>;
  classification_lte?: Maybe<String>;
  classification_gt?: Maybe<String>;
  classification_gte?: Maybe<String>;
  classification_contains?: Maybe<String>;
  classification_not_contains?: Maybe<String>;
  classification_starts_with?: Maybe<String>;
  classification_not_starts_with?: Maybe<String>;
  classification_ends_with?: Maybe<String>;
  classification_not_ends_with?: Maybe<String>;
  projectManager_every?: Maybe<ProjectManagerWhereInput>;
  projectManager_some?: Maybe<ProjectManagerWhereInput>;
  projectManager_none?: Maybe<ProjectManagerWhereInput>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  OR?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
  NOT?: Maybe<CustomerWhereInput[] | CustomerWhereInput>;
}

export interface MainProjectPhasesCreateInput {
  id?: Maybe<ID_Input>;
  salesphase: PhasePayloadCreateOneInput;
}

export type AnalyzeCustomerFormWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PhasePayloadCreateOneInput {
  create?: Maybe<PhasePayloadCreateInput>;
  connect?: Maybe<PhasePayloadWhereUniqueInput>;
}

export interface MainProjectPhasesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  salesphase?: Maybe<PhasePayloadWhereInput>;
  AND?: Maybe<MainProjectPhasesWhereInput[] | MainProjectPhasesWhereInput>;
  OR?: Maybe<MainProjectPhasesWhereInput[] | MainProjectPhasesWhereInput>;
  NOT?: Maybe<MainProjectPhasesWhereInput[] | MainProjectPhasesWhereInput>;
}

export interface PhasePayloadCreateInput {
  id?: Maybe<ID_Input>;
  aktiv: Boolean;
  tasks?: Maybe<PhaseFormsPayloadCreateManyWithoutPhaseInput>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  shortDescription?: Maybe<String>;
  description?: Maybe<String>;
}

export interface PhaseFormsPayloadCreateManyWithoutPhaseInput {
  create?: Maybe<
    | PhaseFormsPayloadCreateWithoutPhaseInput[]
    | PhaseFormsPayloadCreateWithoutPhaseInput
  >;
  connect?: Maybe<
    PhaseFormsPayloadWhereUniqueInput[] | PhaseFormsPayloadWhereUniqueInput
  >;
}

export interface PermissionUpdateManyMutationInput {
  buisnessObj?: Maybe<String>;
}

export interface PhaseFormsPayloadCreateWithoutPhaseInput {
  id?: Maybe<ID_Input>;
  until?: Maybe<DateTimeInput>;
  required: Boolean;
  document: String;
  projectManager?: Maybe<UserCreateOneInput>;
  taskTitle: String;
}

export interface PermissionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  buisnessObj?: Maybe<String>;
  buisnessObj_not?: Maybe<String>;
  buisnessObj_in?: Maybe<String[] | String>;
  buisnessObj_not_in?: Maybe<String[] | String>;
  buisnessObj_lt?: Maybe<String>;
  buisnessObj_lte?: Maybe<String>;
  buisnessObj_gt?: Maybe<String>;
  buisnessObj_gte?: Maybe<String>;
  buisnessObj_contains?: Maybe<String>;
  buisnessObj_not_contains?: Maybe<String>;
  buisnessObj_starts_with?: Maybe<String>;
  buisnessObj_not_starts_with?: Maybe<String>;
  buisnessObj_ends_with?: Maybe<String>;
  buisnessObj_not_ends_with?: Maybe<String>;
  actions_every?: Maybe<PermissionActionWhereInput>;
  actions_some?: Maybe<PermissionActionWhereInput>;
  actions_none?: Maybe<PermissionActionWhereInput>;
  AND?: Maybe<PermissionWhereInput[] | PermissionWhereInput>;
  OR?: Maybe<PermissionWhereInput[] | PermissionWhereInput>;
  NOT?: Maybe<PermissionWhereInput[] | PermissionWhereInput>;
}

export interface MainProjectUpdateInput {
  customer?: Maybe<CustomerUpdateOneRequiredInput>;
  shortDescription?: Maybe<String>;
  status?: Maybe<Int>;
  projectManager?: Maybe<ProjectManagerUpdateManyInput>;
  notes?: Maybe<String>;
  projects?: Maybe<ProjectUpdateManyWithoutMainProjectInput>;
  phases?: Maybe<MainProjectPhasesUpdateOneRequiredInput>;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface CustomerUpdateOneRequiredInput {
  create?: Maybe<CustomerCreateInput>;
  update?: Maybe<CustomerUpdateDataInput>;
  upsert?: Maybe<CustomerUpsertNestedInput>;
  connect?: Maybe<CustomerWhereUniqueInput>;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface CustomerUpdateDataInput {
  logo?: Maybe<String>;
  name?: Maybe<String>;
  branch?: Maybe<BranchUpdateManyInput>;
  classification?: Maybe<String>;
  projectManager?: Maybe<ProjectManagerUpdateManyInput>;
  notes?: Maybe<String>;
}

export interface MainProjectPhasesUpsertNestedInput {
  update: MainProjectPhasesUpdateDataInput;
  create: MainProjectPhasesCreateInput;
}

export interface CustomerUpsertNestedInput {
  update: CustomerUpdateDataInput;
  create: CustomerCreateInput;
}

export interface PhaseFormsPayloadUpdateWithoutPhaseDataInput {
  until?: Maybe<DateTimeInput>;
  required?: Maybe<Boolean>;
  document?: Maybe<String>;
  projectManager?: Maybe<UserUpdateOneInput>;
  taskTitle?: Maybe<String>;
}

export interface ProjectUpdateManyWithoutMainProjectInput {
  create?: Maybe<
    | ProjectCreateWithoutMainProjectInput[]
    | ProjectCreateWithoutMainProjectInput
  >;
  delete?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  set?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  disconnect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  update?: Maybe<
    | ProjectUpdateWithWhereUniqueWithoutMainProjectInput[]
    | ProjectUpdateWithWhereUniqueWithoutMainProjectInput
  >;
  upsert?: Maybe<
    | ProjectUpsertWithWhereUniqueWithoutMainProjectInput[]
    | ProjectUpsertWithWhereUniqueWithoutMainProjectInput
  >;
  deleteMany?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  updateMany?: Maybe<
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput
  >;
}

export interface MainProjectPhasesUpdateOneRequiredInput {
  create?: Maybe<MainProjectPhasesCreateInput>;
  update?: Maybe<MainProjectPhasesUpdateDataInput>;
  upsert?: Maybe<MainProjectPhasesUpsertNestedInput>;
  connect?: Maybe<MainProjectPhasesWhereUniqueInput>;
}

export interface ProjectUpdateWithWhereUniqueWithoutMainProjectInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutMainProjectDataInput;
}

export type BranchWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProjectUpdateWithoutMainProjectDataInput {
  status?: Maybe<Int>;
  shortDescription?: Maybe<String>;
  notes?: Maybe<String>;
  product?: Maybe<ProductUpdateOneRequiredInput>;
  phases?: Maybe<ProjectPhaseUpdateManyInput>;
  projectManager?: Maybe<ProjectManagerUpdateManyInput>;
}

export type BuisnessWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductUpdateOneRequiredInput {
  create?: Maybe<ProductCreateInput>;
  update?: Maybe<ProductUpdateDataInput>;
  upsert?: Maybe<ProductUpsertNestedInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AddressWhereInput>;
  AND?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  OR?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
  NOT?: Maybe<AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput>;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export type MainProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ProjectPhaseUpdateManyInput {
  create?: Maybe<ProjectPhaseCreateInput[] | ProjectPhaseCreateInput>;
  update?: Maybe<
    | ProjectPhaseUpdateWithWhereUniqueNestedInput[]
    | ProjectPhaseUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProjectPhaseUpsertWithWhereUniqueNestedInput[]
    | ProjectPhaseUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ProjectPhaseWhereUniqueInput[] | ProjectPhaseWhereUniqueInput>;
  connect?: Maybe<
    ProjectPhaseWhereUniqueInput[] | ProjectPhaseWhereUniqueInput
  >;
  set?: Maybe<ProjectPhaseWhereUniqueInput[] | ProjectPhaseWhereUniqueInput>;
  disconnect?: Maybe<
    ProjectPhaseWhereUniqueInput[] | ProjectPhaseWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ProjectPhaseScalarWhereInput[] | ProjectPhaseScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProjectPhaseUpdateManyWithWhereNestedInput[]
    | ProjectPhaseUpdateManyWithWhereNestedInput
  >;
}

export interface PhaseFormsPayloadUpdateInput {
  phase?: Maybe<PhasePayloadUpdateOneRequiredWithoutTasksInput>;
  until?: Maybe<DateTimeInput>;
  required?: Maybe<Boolean>;
  document?: Maybe<String>;
  projectManager?: Maybe<UserUpdateOneInput>;
  taskTitle?: Maybe<String>;
}

export interface ProjectPhaseUpdateWithWhereUniqueNestedInput {
  where: ProjectPhaseWhereUniqueInput;
  data: ProjectPhaseUpdateDataInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  profileImage?: Maybe<String>;
  profileImage_not?: Maybe<String>;
  profileImage_in?: Maybe<String[] | String>;
  profileImage_not_in?: Maybe<String[] | String>;
  profileImage_lt?: Maybe<String>;
  profileImage_lte?: Maybe<String>;
  profileImage_gt?: Maybe<String>;
  profileImage_gte?: Maybe<String>;
  profileImage_contains?: Maybe<String>;
  profileImage_not_contains?: Maybe<String>;
  profileImage_starts_with?: Maybe<String>;
  profileImage_not_starts_with?: Maybe<String>;
  profileImage_ends_with?: Maybe<String>;
  profileImage_not_ends_with?: Maybe<String>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  telephone?: Maybe<String>;
  telephone_not?: Maybe<String>;
  telephone_in?: Maybe<String[] | String>;
  telephone_not_in?: Maybe<String[] | String>;
  telephone_lt?: Maybe<String>;
  telephone_lte?: Maybe<String>;
  telephone_gt?: Maybe<String>;
  telephone_gte?: Maybe<String>;
  telephone_contains?: Maybe<String>;
  telephone_not_contains?: Maybe<String>;
  telephone_starts_with?: Maybe<String>;
  telephone_not_starts_with?: Maybe<String>;
  telephone_ends_with?: Maybe<String>;
  telephone_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface ProjectPhaseUpdateDataInput {
  name?: Maybe<String>;
  status?: Maybe<Int>;
  roles?: Maybe<ProjectPhaseUpdaterolesInput>;
  users?: Maybe<ProjectPhaseUpdateusersInput>;
  forms?: Maybe<ProjectFormsUpdateOneInput>;
}

export interface PermissionCreateInput {
  id?: Maybe<ID_Input>;
  buisnessObj: String;
  actions?: Maybe<PermissionActionCreateManyInput>;
}

export interface ProjectPhaseUpdaterolesInput {
  set?: Maybe<String[] | String>;
}

export interface PhasePayloadUpdateDataInput {
  aktiv?: Maybe<Boolean>;
  tasks?: Maybe<PhaseFormsPayloadUpdateManyWithoutPhaseInput>;
}

export interface ProjectPhaseUpdateusersInput {
  set?: Maybe<String[] | String>;
}

export interface ContactWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  profileImage?: Maybe<String>;
  profileImage_not?: Maybe<String>;
  profileImage_in?: Maybe<String[] | String>;
  profileImage_not_in?: Maybe<String[] | String>;
  profileImage_lt?: Maybe<String>;
  profileImage_lte?: Maybe<String>;
  profileImage_gt?: Maybe<String>;
  profileImage_gte?: Maybe<String>;
  profileImage_contains?: Maybe<String>;
  profileImage_not_contains?: Maybe<String>;
  profileImage_starts_with?: Maybe<String>;
  profileImage_not_starts_with?: Maybe<String>;
  profileImage_ends_with?: Maybe<String>;
  profileImage_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstname?: Maybe<String>;
  firstname_not?: Maybe<String>;
  firstname_in?: Maybe<String[] | String>;
  firstname_not_in?: Maybe<String[] | String>;
  firstname_lt?: Maybe<String>;
  firstname_lte?: Maybe<String>;
  firstname_gt?: Maybe<String>;
  firstname_gte?: Maybe<String>;
  firstname_contains?: Maybe<String>;
  firstname_not_contains?: Maybe<String>;
  firstname_starts_with?: Maybe<String>;
  firstname_not_starts_with?: Maybe<String>;
  firstname_ends_with?: Maybe<String>;
  firstname_not_ends_with?: Maybe<String>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  nickname?: Maybe<String>;
  nickname_not?: Maybe<String>;
  nickname_in?: Maybe<String[] | String>;
  nickname_not_in?: Maybe<String[] | String>;
  nickname_lt?: Maybe<String>;
  nickname_lte?: Maybe<String>;
  nickname_gt?: Maybe<String>;
  nickname_gte?: Maybe<String>;
  nickname_contains?: Maybe<String>;
  nickname_not_contains?: Maybe<String>;
  nickname_starts_with?: Maybe<String>;
  nickname_not_starts_with?: Maybe<String>;
  nickname_ends_with?: Maybe<String>;
  nickname_not_ends_with?: Maybe<String>;
  telephone?: Maybe<String>;
  telephone_not?: Maybe<String>;
  telephone_in?: Maybe<String[] | String>;
  telephone_not_in?: Maybe<String[] | String>;
  telephone_lt?: Maybe<String>;
  telephone_lte?: Maybe<String>;
  telephone_gt?: Maybe<String>;
  telephone_gte?: Maybe<String>;
  telephone_contains?: Maybe<String>;
  telephone_not_contains?: Maybe<String>;
  telephone_starts_with?: Maybe<String>;
  telephone_not_starts_with?: Maybe<String>;
  telephone_ends_with?: Maybe<String>;
  telephone_not_ends_with?: Maybe<String>;
  mobile?: Maybe<String>;
  mobile_not?: Maybe<String>;
  mobile_in?: Maybe<String[] | String>;
  mobile_not_in?: Maybe<String[] | String>;
  mobile_lt?: Maybe<String>;
  mobile_lte?: Maybe<String>;
  mobile_gt?: Maybe<String>;
  mobile_gte?: Maybe<String>;
  mobile_contains?: Maybe<String>;
  mobile_not_contains?: Maybe<String>;
  mobile_starts_with?: Maybe<String>;
  mobile_not_starts_with?: Maybe<String>;
  mobile_ends_with?: Maybe<String>;
  mobile_not_ends_with?: Maybe<String>;
  position?: Maybe<String>;
  position_not?: Maybe<String>;
  position_in?: Maybe<String[] | String>;
  position_not_in?: Maybe<String[] | String>;
  position_lt?: Maybe<String>;
  position_lte?: Maybe<String>;
  position_gt?: Maybe<String>;
  position_gte?: Maybe<String>;
  position_contains?: Maybe<String>;
  position_not_contains?: Maybe<String>;
  position_starts_with?: Maybe<String>;
  position_not_starts_with?: Maybe<String>;
  position_ends_with?: Maybe<String>;
  position_not_ends_with?: Maybe<String>;
  notes?: Maybe<String>;
  notes_not?: Maybe<String>;
  notes_in?: Maybe<String[] | String>;
  notes_not_in?: Maybe<String[] | String>;
  notes_lt?: Maybe<String>;
  notes_lte?: Maybe<String>;
  notes_gt?: Maybe<String>;
  notes_gte?: Maybe<String>;
  notes_contains?: Maybe<String>;
  notes_not_contains?: Maybe<String>;
  notes_starts_with?: Maybe<String>;
  notes_not_starts_with?: Maybe<String>;
  notes_ends_with?: Maybe<String>;
  notes_not_ends_with?: Maybe<String>;
  AND?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  OR?: Maybe<ContactWhereInput[] | ContactWhereInput>;
  NOT?: Maybe<ContactWhereInput[] | ContactWhereInput>;
}

export interface ProjectFormsUpdateOneInput {
  create?: Maybe<ProjectFormsCreateInput>;
  update?: Maybe<ProjectFormsUpdateDataInput>;
  upsert?: Maybe<ProjectFormsUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProjectFormsWhereUniqueInput>;
}

export interface ProjectManagerUpdateInput {
  order?: Maybe<Int>;
  manager?: Maybe<UserUpdateOneRequiredInput>;
  notes?: Maybe<String>;
}

export interface ProjectFormsUpdateDataInput {
  criteriaCalculator?: Maybe<CriteriaCalculatorUpdateOneInput>;
}

export interface PermissionActionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  AND?: Maybe<PermissionActionWhereInput[] | PermissionActionWhereInput>;
  OR?: Maybe<PermissionActionWhereInput[] | PermissionActionWhereInput>;
  NOT?: Maybe<PermissionActionWhereInput[] | PermissionActionWhereInput>;
}

export interface ProjectFormsUpsertNestedInput {
  update: ProjectFormsUpdateDataInput;
  create: ProjectFormsCreateInput;
}

export interface CriteriaCalculatorUpsertNestedInput {
  update: CriteriaCalculatorUpdateDataInput;
  create: CriteriaCalculatorCreateInput;
}

export interface CriteriaCalculatorUpdateDataInput {
  status?: Maybe<Int>;
  required?: Maybe<Boolean>;
  milestone?: Maybe<Boolean>;
}

export interface CriteriaCalculatorUpdateOneInput {
  create?: Maybe<CriteriaCalculatorCreateInput>;
  update?: Maybe<CriteriaCalculatorUpdateDataInput>;
  upsert?: Maybe<CriteriaCalculatorUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CriteriaCalculatorWhereUniqueInput>;
}

export interface PermissionActionUpdateManyInput {
  create?: Maybe<PermissionActionCreateInput[] | PermissionActionCreateInput>;
  update?: Maybe<
    | PermissionActionUpdateWithWhereUniqueNestedInput[]
    | PermissionActionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PermissionActionUpsertWithWhereUniqueNestedInput[]
    | PermissionActionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    PermissionActionWhereUniqueInput[] | PermissionActionWhereUniqueInput
  >;
  connect?: Maybe<
    PermissionActionWhereUniqueInput[] | PermissionActionWhereUniqueInput
  >;
  set?: Maybe<
    PermissionActionWhereUniqueInput[] | PermissionActionWhereUniqueInput
  >;
  disconnect?: Maybe<
    PermissionActionWhereUniqueInput[] | PermissionActionWhereUniqueInput
  >;
  deleteMany?: Maybe<
    PermissionActionScalarWhereInput[] | PermissionActionScalarWhereInput
  >;
  updateMany?: Maybe<
    | PermissionActionUpdateManyWithWhereNestedInput[]
    | PermissionActionUpdateManyWithWhereNestedInput
  >;
}

export interface MainProjectCreateWithoutProjectsInput {
  id?: Maybe<Int>;
  customer: CustomerCreateOneInput;
  shortDescription: String;
  status: Int;
  projectManager?: Maybe<ProjectManagerCreateManyInput>;
  notes?: Maybe<String>;
  phases: MainProjectPhasesCreateOneInput;
}

export type CriteriaCalculatorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AddressCreateInput {
  id?: Maybe<ID_Input>;
  postalCode: String;
  city: String;
  street: String;
  country: String;
}

export interface PhaseFormsPayloadUpdateManyWithWhereNestedInput {
  where: PhaseFormsPayloadScalarWhereInput;
  data: PhaseFormsPayloadUpdateManyDataInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  profileImage?: String;
  firstname: String;
  lastname: String;
  nickname?: String;
  telephone?: String;
  mobile?: String;
  position?: String;
  roles: String[];
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  profileImage: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  nickname: () => Promise<String>;
  telephone: () => Promise<String>;
  mobile: () => Promise<String>;
  position: () => Promise<String>;
  roles: () => Promise<String[]>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  profileImage: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<String[]>>;
}

export interface AnalyzeCustomerForm {
  id: ID_Output;
  result?: String;
}

export interface AnalyzeCustomerFormPromise
  extends Promise<AnalyzeCustomerForm>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  payload: <T = PhaseFormsPayloadPromise>() => T;
  result: () => Promise<String>;
}

export interface AnalyzeCustomerFormSubscription
  extends Promise<AsyncIterator<AnalyzeCustomerForm>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  payload: <T = PhaseFormsPayloadSubscription>() => T;
  result: () => Promise<AsyncIterator<String>>;
}

export interface AnalyzeCustomerFormNullablePromise
  extends Promise<AnalyzeCustomerForm | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  payload: <T = PhaseFormsPayloadPromise>() => T;
  result: () => Promise<String>;
}

export interface AnalyzeCustomerFormEdge {
  node: AnalyzeCustomerForm;
  cursor: String;
}

export interface AnalyzeCustomerFormEdgePromise
  extends Promise<AnalyzeCustomerFormEdge>,
    Fragmentable {
  node: <T = AnalyzeCustomerFormPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AnalyzeCustomerFormEdgeSubscription
  extends Promise<AsyncIterator<AnalyzeCustomerFormEdge>>,
    Fragmentable {
  node: <T = AnalyzeCustomerFormSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectManager {
  id: ID_Output;
  order: Int;
  notes?: String;
}

export interface ProjectManagerPromise
  extends Promise<ProjectManager>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  manager: <T = UserPromise>() => T;
  notes: () => Promise<String>;
}

export interface ProjectManagerSubscription
  extends Promise<AsyncIterator<ProjectManager>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  manager: <T = UserSubscription>() => T;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface ProjectManagerNullablePromise
  extends Promise<ProjectManager | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  manager: <T = UserPromise>() => T;
  notes: () => Promise<String>;
}

export interface AggregateAnalyzeCustomerForm {
  count: Int;
}

export interface AggregateAnalyzeCustomerFormPromise
  extends Promise<AggregateAnalyzeCustomerForm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAnalyzeCustomerFormSubscription
  extends Promise<AsyncIterator<AggregateAnalyzeCustomerForm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhaseFormsPayload {
  id: ID_Output;
  until?: DateTimeOutput;
  required: Boolean;
  document: String;
  taskTitle: String;
}

export interface PhaseFormsPayloadPromise
  extends Promise<PhaseFormsPayload>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phase: <T = PhasePayloadPromise>() => T;
  until: () => Promise<DateTimeOutput>;
  required: () => Promise<Boolean>;
  document: () => Promise<String>;
  projectManager: <T = UserPromise>() => T;
  taskTitle: () => Promise<String>;
}

export interface PhaseFormsPayloadSubscription
  extends Promise<AsyncIterator<PhaseFormsPayload>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  phase: <T = PhasePayloadSubscription>() => T;
  until: () => Promise<AsyncIterator<DateTimeOutput>>;
  required: () => Promise<AsyncIterator<Boolean>>;
  document: () => Promise<AsyncIterator<String>>;
  projectManager: <T = UserSubscription>() => T;
  taskTitle: () => Promise<AsyncIterator<String>>;
}

export interface PhaseFormsPayloadNullablePromise
  extends Promise<PhaseFormsPayload | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  phase: <T = PhasePayloadPromise>() => T;
  until: () => Promise<DateTimeOutput>;
  required: () => Promise<Boolean>;
  document: () => Promise<String>;
  projectManager: <T = UserPromise>() => T;
  taskTitle: () => Promise<String>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Customer {
  id: Int;
  logo?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  classification?: String;
  notes?: String;
}

export interface CustomerPromise extends Promise<Customer>, Fragmentable {
  id: () => Promise<Int>;
  logo: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  branch: <T = FragmentableArray<Branch>>(args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classification: () => Promise<String>;
  projectManager: <T = FragmentableArray<ProjectManager>>(args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notes: () => Promise<String>;
}

export interface CustomerSubscription
  extends Promise<AsyncIterator<Customer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  logo: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  branch: <T = Promise<AsyncIterator<BranchSubscription>>>(args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classification: () => Promise<AsyncIterator<String>>;
  projectManager: <
    T = Promise<AsyncIterator<ProjectManagerSubscription>>
  >(args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface CustomerNullablePromise
  extends Promise<Customer | null>,
    Fragmentable {
  id: () => Promise<Int>;
  logo: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  branch: <T = FragmentableArray<Branch>>(args?: {
    where?: BranchWhereInput;
    orderBy?: BranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  classification: () => Promise<String>;
  projectManager: <T = FragmentableArray<ProjectManager>>(args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notes: () => Promise<String>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Address {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  postalCode: String;
  city: String;
  street: String;
  country: String;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postalCode: () => Promise<String>;
  city: () => Promise<String>;
  street: () => Promise<String>;
  country: () => Promise<String>;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
}

export interface AddressNullablePromise
  extends Promise<Address | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postalCode: () => Promise<String>;
  city: () => Promise<String>;
  street: () => Promise<String>;
  country: () => Promise<String>;
}

export interface AggregateProjectPhase {
  count: Int;
}

export interface AggregateProjectPhasePromise
  extends Promise<AggregateProjectPhase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectPhaseSubscription
  extends Promise<AsyncIterator<AggregateProjectPhase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface ProjectPhaseConnection {
  pageInfo: PageInfo;
  edges: ProjectPhaseEdge[];
}

export interface ProjectPhaseConnectionPromise
  extends Promise<ProjectPhaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectPhaseEdge>>() => T;
  aggregate: <T = AggregateProjectPhasePromise>() => T;
}

export interface ProjectPhaseConnectionSubscription
  extends Promise<AsyncIterator<ProjectPhaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectPhaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectPhaseSubscription>() => T;
}

export interface AddressPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  postalCode: String;
  city: String;
  street: String;
  country: String;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  postalCode: () => Promise<String>;
  city: () => Promise<String>;
  street: () => Promise<String>;
  country: () => Promise<String>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  postalCode: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
}

export interface ProjectManagerEdge {
  node: ProjectManager;
  cursor: String;
}

export interface ProjectManagerEdgePromise
  extends Promise<ProjectManagerEdge>,
    Fragmentable {
  node: <T = ProjectManagerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectManagerEdgeSubscription
  extends Promise<AsyncIterator<ProjectManagerEdge>>,
    Fragmentable {
  node: <T = ProjectManagerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCriteriaCalculator {
  count: Int;
}

export interface AggregateCriteriaCalculatorPromise
  extends Promise<AggregateCriteriaCalculator>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCriteriaCalculatorSubscription
  extends Promise<AsyncIterator<AggregateCriteriaCalculator>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateProjectForms {
  count: Int;
}

export interface AggregateProjectFormsPromise
  extends Promise<AggregateProjectForms>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectFormsSubscription
  extends Promise<AsyncIterator<AggregateProjectForms>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AnalyzeCustomerFormSubscriptionPayload {
  mutation: MutationType;
  node: AnalyzeCustomerForm;
  updatedFields: String[];
  previousValues: AnalyzeCustomerFormPreviousValues;
}

export interface AnalyzeCustomerFormSubscriptionPayloadPromise
  extends Promise<AnalyzeCustomerFormSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AnalyzeCustomerFormPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AnalyzeCustomerFormPreviousValuesPromise>() => T;
}

export interface AnalyzeCustomerFormSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AnalyzeCustomerFormSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AnalyzeCustomerFormSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AnalyzeCustomerFormPreviousValuesSubscription>() => T;
}

export interface ProjectFormsConnection {
  pageInfo: PageInfo;
  edges: ProjectFormsEdge[];
}

export interface ProjectFormsConnectionPromise
  extends Promise<ProjectFormsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectFormsEdge>>() => T;
  aggregate: <T = AggregateProjectFormsPromise>() => T;
}

export interface ProjectFormsConnectionSubscription
  extends Promise<AsyncIterator<ProjectFormsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectFormsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectFormsSubscription>() => T;
}

export interface AnalyzeCustomerFormPreviousValues {
  id: ID_Output;
  result?: String;
}

export interface AnalyzeCustomerFormPreviousValuesPromise
  extends Promise<AnalyzeCustomerFormPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  result: () => Promise<String>;
}

export interface AnalyzeCustomerFormPreviousValuesSubscription
  extends Promise<AsyncIterator<AnalyzeCustomerFormPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  result: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CriteriaCalculatorEdge {
  node: CriteriaCalculator;
  cursor: String;
}

export interface CriteriaCalculatorEdgePromise
  extends Promise<CriteriaCalculatorEdge>,
    Fragmentable {
  node: <T = CriteriaCalculatorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CriteriaCalculatorEdgeSubscription
  extends Promise<AsyncIterator<CriteriaCalculatorEdge>>,
    Fragmentable {
  node: <T = CriteriaCalculatorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface BranchSubscriptionPayload {
  mutation: MutationType;
  node: Branch;
  updatedFields: String[];
  previousValues: BranchPreviousValues;
}

export interface BranchSubscriptionPayloadPromise
  extends Promise<BranchSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BranchPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BranchPreviousValuesPromise>() => T;
}

export interface BranchSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BranchSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BranchSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BranchPreviousValuesSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BranchPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  type: String;
}

export interface BranchPreviousValuesPromise
  extends Promise<BranchPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  type: () => Promise<String>;
}

export interface BranchPreviousValuesSubscription
  extends Promise<AsyncIterator<BranchPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePhasePayload {
  count: Int;
}

export interface AggregatePhasePayloadPromise
  extends Promise<AggregatePhasePayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhasePayloadSubscription
  extends Promise<AsyncIterator<AggregatePhasePayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CriteriaCalculatorConnection {
  pageInfo: PageInfo;
  edges: CriteriaCalculatorEdge[];
}

export interface CriteriaCalculatorConnectionPromise
  extends Promise<CriteriaCalculatorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CriteriaCalculatorEdge>>() => T;
  aggregate: <T = AggregateCriteriaCalculatorPromise>() => T;
}

export interface CriteriaCalculatorConnectionSubscription
  extends Promise<AsyncIterator<CriteriaCalculatorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CriteriaCalculatorEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCriteriaCalculatorSubscription>() => T;
}

export interface PhasePayloadConnection {
  pageInfo: PageInfo;
  edges: PhasePayloadEdge[];
}

export interface PhasePayloadConnectionPromise
  extends Promise<PhasePayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhasePayloadEdge>>() => T;
  aggregate: <T = AggregatePhasePayloadPromise>() => T;
}

export interface PhasePayloadConnectionSubscription
  extends Promise<AsyncIterator<PhasePayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhasePayloadEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhasePayloadSubscription>() => T;
}

export interface BuisnessSubscriptionPayload {
  mutation: MutationType;
  node: Buisness;
  updatedFields: String[];
  previousValues: BuisnessPreviousValues;
}

export interface BuisnessSubscriptionPayloadPromise
  extends Promise<BuisnessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BuisnessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BuisnessPreviousValuesPromise>() => T;
}

export interface BuisnessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BuisnessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BuisnessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BuisnessPreviousValuesSubscription>() => T;
}

export interface AggregatePhaseFormsPayload {
  count: Int;
}

export interface AggregatePhaseFormsPayloadPromise
  extends Promise<AggregatePhaseFormsPayload>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePhaseFormsPayloadSubscription
  extends Promise<AsyncIterator<AggregatePhaseFormsPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BuisnessPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  shortDescription: String;
  longDescription: String;
}

export interface BuisnessPreviousValuesPromise
  extends Promise<BuisnessPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  shortDescription: () => Promise<String>;
  longDescription: () => Promise<String>;
}

export interface BuisnessPreviousValuesSubscription
  extends Promise<AsyncIterator<BuisnessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  longDescription: () => Promise<AsyncIterator<String>>;
}

export interface PhaseFormsPayloadConnection {
  pageInfo: PageInfo;
  edges: PhaseFormsPayloadEdge[];
}

export interface PhaseFormsPayloadConnectionPromise
  extends Promise<PhaseFormsPayloadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PhaseFormsPayloadEdge>>() => T;
  aggregate: <T = AggregatePhaseFormsPayloadPromise>() => T;
}

export interface PhaseFormsPayloadConnectionSubscription
  extends Promise<AsyncIterator<PhaseFormsPayloadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PhaseFormsPayloadEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePhaseFormsPayloadSubscription>() => T;
}

export interface PhasePayload {
  id: ID_Output;
  aktiv: Boolean;
}

export interface PhasePayloadPromise
  extends Promise<PhasePayload>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  aktiv: () => Promise<Boolean>;
  tasks: <T = FragmentableArray<PhaseFormsPayload>>(args?: {
    where?: PhaseFormsPayloadWhereInput;
    orderBy?: PhaseFormsPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PhasePayloadSubscription
  extends Promise<AsyncIterator<PhasePayload>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  aktiv: () => Promise<AsyncIterator<Boolean>>;
  tasks: <T = Promise<AsyncIterator<PhaseFormsPayloadSubscription>>>(args?: {
    where?: PhaseFormsPayloadWhereInput;
    orderBy?: PhaseFormsPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PhasePayloadNullablePromise
  extends Promise<PhasePayload | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  aktiv: () => Promise<Boolean>;
  tasks: <T = FragmentableArray<PhaseFormsPayload>>(args?: {
    where?: PhaseFormsPayloadWhereInput;
    orderBy?: PhaseFormsPayloadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PermissionActionEdge {
  node: PermissionAction;
  cursor: String;
}

export interface PermissionActionEdgePromise
  extends Promise<PermissionActionEdge>,
    Fragmentable {
  node: <T = PermissionActionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionActionEdgeSubscription
  extends Promise<AsyncIterator<PermissionActionEdge>>,
    Fragmentable {
  node: <T = PermissionActionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContactSubscriptionPayload {
  mutation: MutationType;
  node: Contact;
  updatedFields: String[];
  previousValues: ContactPreviousValues;
}

export interface ContactSubscriptionPayloadPromise
  extends Promise<ContactSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactPreviousValuesPromise>() => T;
}

export interface ContactSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactPreviousValuesSubscription>() => T;
}

export interface AggregatePermission {
  count: Int;
}

export interface AggregatePermissionPromise
  extends Promise<AggregatePermission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionSubscription
  extends Promise<AsyncIterator<AggregatePermission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactPreviousValues {
  id: ID_Output;
  profileImage?: String;
  email?: String;
  firstname: String;
  lastname?: String;
  nickname?: String;
  telephone?: String;
  mobile?: String;
  position?: String;
  notes?: String;
}

export interface ContactPreviousValuesPromise
  extends Promise<ContactPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  profileImage: () => Promise<String>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  nickname: () => Promise<String>;
  telephone: () => Promise<String>;
  mobile: () => Promise<String>;
  position: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface ContactPreviousValuesSubscription
  extends Promise<AsyncIterator<ContactPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  profileImage: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface PermissionConnection {
  pageInfo: PageInfo;
  edges: PermissionEdge[];
}

export interface PermissionConnectionPromise
  extends Promise<PermissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionEdge>>() => T;
  aggregate: <T = AggregatePermissionPromise>() => T;
}

export interface PermissionConnectionSubscription
  extends Promise<AsyncIterator<PermissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionSubscription>() => T;
}

export interface CriteriaCalculator {
  id: ID_Output;
  status: Int;
  required: Boolean;
  milestone: Boolean;
}

export interface CriteriaCalculatorPromise
  extends Promise<CriteriaCalculator>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Int>;
  required: () => Promise<Boolean>;
  milestone: () => Promise<Boolean>;
}

export interface CriteriaCalculatorSubscription
  extends Promise<AsyncIterator<CriteriaCalculator>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Int>>;
  required: () => Promise<AsyncIterator<Boolean>>;
  milestone: () => Promise<AsyncIterator<Boolean>>;
}

export interface CriteriaCalculatorNullablePromise
  extends Promise<CriteriaCalculator | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Int>;
  required: () => Promise<Boolean>;
  milestone: () => Promise<Boolean>;
}

export interface PermissionAction {
  id: ID_Output;
  type?: String;
  roles: String[];
}

export interface PermissionActionPromise
  extends Promise<PermissionAction>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  roles: () => Promise<String[]>;
}

export interface PermissionActionSubscription
  extends Promise<AsyncIterator<PermissionAction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  roles: () => Promise<AsyncIterator<String[]>>;
}

export interface PermissionActionNullablePromise
  extends Promise<PermissionAction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  roles: () => Promise<String[]>;
}

export interface CriteriaCalculatorSubscriptionPayload {
  mutation: MutationType;
  node: CriteriaCalculator;
  updatedFields: String[];
  previousValues: CriteriaCalculatorPreviousValues;
}

export interface CriteriaCalculatorSubscriptionPayloadPromise
  extends Promise<CriteriaCalculatorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CriteriaCalculatorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CriteriaCalculatorPreviousValuesPromise>() => T;
}

export interface CriteriaCalculatorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CriteriaCalculatorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CriteriaCalculatorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CriteriaCalculatorPreviousValuesSubscription>() => T;
}

export interface Permission {
  id: ID_Output;
  buisnessObj: String;
}

export interface PermissionPromise extends Promise<Permission>, Fragmentable {
  id: () => Promise<ID_Output>;
  buisnessObj: () => Promise<String>;
  actions: <T = FragmentableArray<PermissionAction>>(args?: {
    where?: PermissionActionWhereInput;
    orderBy?: PermissionActionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PermissionSubscription
  extends Promise<AsyncIterator<Permission>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  buisnessObj: () => Promise<AsyncIterator<String>>;
  actions: <T = Promise<AsyncIterator<PermissionActionSubscription>>>(args?: {
    where?: PermissionActionWhereInput;
    orderBy?: PermissionActionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PermissionNullablePromise
  extends Promise<Permission | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  buisnessObj: () => Promise<String>;
  actions: <T = FragmentableArray<PermissionAction>>(args?: {
    where?: PermissionActionWhereInput;
    orderBy?: PermissionActionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CriteriaCalculatorPreviousValues {
  id: ID_Output;
  status: Int;
  required: Boolean;
  milestone: Boolean;
}

export interface CriteriaCalculatorPreviousValuesPromise
  extends Promise<CriteriaCalculatorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Int>;
  required: () => Promise<Boolean>;
  milestone: () => Promise<Boolean>;
}

export interface CriteriaCalculatorPreviousValuesSubscription
  extends Promise<AsyncIterator<CriteriaCalculatorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Int>>;
  required: () => Promise<AsyncIterator<Boolean>>;
  milestone: () => Promise<AsyncIterator<Boolean>>;
}

export interface MainProjectPhasesEdge {
  node: MainProjectPhases;
  cursor: String;
}

export interface MainProjectPhasesEdgePromise
  extends Promise<MainProjectPhasesEdge>,
    Fragmentable {
  node: <T = MainProjectPhasesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MainProjectPhasesEdgeSubscription
  extends Promise<AsyncIterator<MainProjectPhasesEdge>>,
    Fragmentable {
  node: <T = MainProjectPhasesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContact {
  count: Int;
}

export interface AggregateContactPromise
  extends Promise<AggregateContact>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSubscription
  extends Promise<AsyncIterator<AggregateContact>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface CustomerSubscriptionPayload {
  mutation: MutationType;
  node: Customer;
  updatedFields: String[];
  previousValues: CustomerPreviousValues;
}

export interface CustomerSubscriptionPayloadPromise
  extends Promise<CustomerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CustomerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CustomerPreviousValuesPromise>() => T;
}

export interface CustomerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CustomerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CustomerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CustomerPreviousValuesSubscription>() => T;
}

export interface MainProjectEdge {
  node: MainProject;
  cursor: String;
}

export interface MainProjectEdgePromise
  extends Promise<MainProjectEdge>,
    Fragmentable {
  node: <T = MainProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MainProjectEdgeSubscription
  extends Promise<AsyncIterator<MainProjectEdge>>,
    Fragmentable {
  node: <T = MainProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMainProject {
  count: Int;
}

export interface AggregateMainProjectPromise
  extends Promise<AggregateMainProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMainProjectSubscription
  extends Promise<AsyncIterator<AggregateMainProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  profileImage?: String;
  firstname: String;
  lastname: String;
  nickname?: String;
  telephone?: String;
  mobile?: String;
  position?: String;
  roles: String[];
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  profileImage: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  nickname: () => Promise<String>;
  telephone: () => Promise<String>;
  mobile: () => Promise<String>;
  position: () => Promise<String>;
  roles: () => Promise<String[]>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  profileImage: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<String[]>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  profileImage: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  nickname: () => Promise<String>;
  telephone: () => Promise<String>;
  mobile: () => Promise<String>;
  position: () => Promise<String>;
  roles: () => Promise<String[]>;
}

export interface MainProjectConnection {
  pageInfo: PageInfo;
  edges: MainProjectEdge[];
}

export interface MainProjectConnectionPromise
  extends Promise<MainProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MainProjectEdge>>() => T;
  aggregate: <T = AggregateMainProjectPromise>() => T;
}

export interface MainProjectConnectionSubscription
  extends Promise<AsyncIterator<MainProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MainProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMainProjectSubscription>() => T;
}

export interface CustomerPreviousValues {
  id: Int;
  logo?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  classification?: String;
  notes?: String;
}

export interface CustomerPreviousValuesPromise
  extends Promise<CustomerPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  logo: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  classification: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface CustomerPreviousValuesSubscription
  extends Promise<AsyncIterator<CustomerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  logo: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  classification: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface MainProjectPhases {
  id: ID_Output;
}

export interface MainProjectPhasesPromise
  extends Promise<MainProjectPhases>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  salesphase: <T = PhasePayloadPromise>() => T;
}

export interface MainProjectPhasesSubscription
  extends Promise<AsyncIterator<MainProjectPhases>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  salesphase: <T = PhasePayloadSubscription>() => T;
}

export interface MainProjectPhasesNullablePromise
  extends Promise<MainProjectPhases | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  salesphase: <T = PhasePayloadPromise>() => T;
}

export interface ProjectPhase {
  id: ID_Output;
  name: String;
  status?: Int;
  roles: String[];
  users: String[];
}

export interface ProjectPhasePromise
  extends Promise<ProjectPhase>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  status: () => Promise<Int>;
  roles: () => Promise<String[]>;
  users: () => Promise<String[]>;
  forms: <T = ProjectFormsPromise>() => T;
}

export interface ProjectPhaseSubscription
  extends Promise<AsyncIterator<ProjectPhase>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  roles: () => Promise<AsyncIterator<String[]>>;
  users: () => Promise<AsyncIterator<String[]>>;
  forms: <T = ProjectFormsSubscription>() => T;
}

export interface ProjectPhaseNullablePromise
  extends Promise<ProjectPhase | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  status: () => Promise<Int>;
  roles: () => Promise<String[]>;
  users: () => Promise<String[]>;
  forms: <T = ProjectFormsPromise>() => T;
}

export interface ContactEdge {
  node: Contact;
  cursor: String;
}

export interface ContactEdgePromise extends Promise<ContactEdge>, Fragmentable {
  node: <T = ContactPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactEdgeSubscription
  extends Promise<AsyncIterator<ContactEdge>>,
    Fragmentable {
  node: <T = ContactSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Project {
  id: Int;
  status: Int;
  shortDescription: String;
  notes?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<Int>;
  status: () => Promise<Int>;
  mainProject: <T = MainProjectPromise>() => T;
  shortDescription: () => Promise<String>;
  notes: () => Promise<String>;
  product: <T = ProductPromise>() => T;
  phases: <T = FragmentableArray<ProjectPhase>>(args?: {
    where?: ProjectPhaseWhereInput;
    orderBy?: ProjectPhaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  projectManager: <T = FragmentableArray<ProjectManager>>(args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
  mainProject: <T = MainProjectSubscription>() => T;
  shortDescription: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  product: <T = ProductSubscription>() => T;
  phases: <T = Promise<AsyncIterator<ProjectPhaseSubscription>>>(args?: {
    where?: ProjectPhaseWhereInput;
    orderBy?: ProjectPhaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  projectManager: <
    T = Promise<AsyncIterator<ProjectManagerSubscription>>
  >(args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProjectNullablePromise
  extends Promise<Project | null>,
    Fragmentable {
  id: () => Promise<Int>;
  status: () => Promise<Int>;
  mainProject: <T = MainProjectPromise>() => T;
  shortDescription: () => Promise<String>;
  notes: () => Promise<String>;
  product: <T = ProductPromise>() => T;
  phases: <T = FragmentableArray<ProjectPhase>>(args?: {
    where?: ProjectPhaseWhereInput;
    orderBy?: ProjectPhaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  projectManager: <T = FragmentableArray<ProjectManager>>(args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface LeadSubscriptionPayload {
  mutation: MutationType;
  node: Lead;
  updatedFields: String[];
  previousValues: LeadPreviousValues;
}

export interface LeadSubscriptionPayloadPromise
  extends Promise<LeadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LeadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LeadPreviousValuesPromise>() => T;
}

export interface LeadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LeadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LeadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LeadPreviousValuesSubscription>() => T;
}

export interface MainProject {
  id: Int;
  shortDescription: String;
  status: Int;
  notes?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MainProjectPromise extends Promise<MainProject>, Fragmentable {
  id: () => Promise<Int>;
  customer: <T = CustomerPromise>() => T;
  shortDescription: () => Promise<String>;
  status: () => Promise<Int>;
  projectManager: <T = FragmentableArray<ProjectManager>>(args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notes: () => Promise<String>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  phases: <T = MainProjectPhasesPromise>() => T;
}

export interface MainProjectSubscription
  extends Promise<AsyncIterator<MainProject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  customer: <T = CustomerSubscription>() => T;
  shortDescription: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  projectManager: <
    T = Promise<AsyncIterator<ProjectManagerSubscription>>
  >(args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notes: () => Promise<AsyncIterator<String>>;
  projects: <T = Promise<AsyncIterator<ProjectSubscription>>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  phases: <T = MainProjectPhasesSubscription>() => T;
}

export interface MainProjectNullablePromise
  extends Promise<MainProject | null>,
    Fragmentable {
  id: () => Promise<Int>;
  customer: <T = CustomerPromise>() => T;
  shortDescription: () => Promise<String>;
  status: () => Promise<Int>;
  projectManager: <T = FragmentableArray<ProjectManager>>(args?: {
    where?: ProjectManagerWhereInput;
    orderBy?: ProjectManagerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notes: () => Promise<String>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  phases: <T = MainProjectPhasesPromise>() => T;
}

export interface LeadPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  customerName: String;
  notes?: String;
}

export interface LeadPreviousValuesPromise
  extends Promise<LeadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  customerName: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface LeadPreviousValuesSubscription
  extends Promise<AsyncIterator<LeadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  customerName: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface LeadEdge {
  node: Lead;
  cursor: String;
}

export interface LeadEdgePromise extends Promise<LeadEdge>, Fragmentable {
  node: <T = LeadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LeadEdgeSubscription
  extends Promise<AsyncIterator<LeadEdge>>,
    Fragmentable {
  node: <T = LeadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContactConnection {
  pageInfo: PageInfo;
  edges: ContactEdge[];
}

export interface ContactConnectionPromise
  extends Promise<ContactConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactEdge>>() => T;
  aggregate: <T = AggregateContactPromise>() => T;
}

export interface ContactConnectionSubscription
  extends Promise<AsyncIterator<ContactConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSubscription>() => T;
}

export interface Lead {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  customerName: String;
  notes?: String;
}

export interface LeadPromise extends Promise<Lead>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  customerName: () => Promise<String>;
  address: <T = AddressPromise>() => T;
  notes: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LeadSubscription
  extends Promise<AsyncIterator<Lead>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  customerName: () => Promise<AsyncIterator<String>>;
  address: <T = AddressSubscription>() => T;
  notes: () => Promise<AsyncIterator<String>>;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface LeadNullablePromise
  extends Promise<Lead | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  customerName: () => Promise<String>;
  address: <T = AddressPromise>() => T;
  notes: () => Promise<String>;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MainProjectSubscriptionPayload {
  mutation: MutationType;
  node: MainProject;
  updatedFields: String[];
  previousValues: MainProjectPreviousValues;
}

export interface MainProjectSubscriptionPayloadPromise
  extends Promise<MainProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MainProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MainProjectPreviousValuesPromise>() => T;
}

export interface MainProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MainProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MainProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MainProjectPreviousValuesSubscription>() => T;
}

export interface CustomerEdge {
  node: Customer;
  cursor: String;
}

export interface CustomerEdgePromise
  extends Promise<CustomerEdge>,
    Fragmentable {
  node: <T = CustomerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CustomerEdgeSubscription
  extends Promise<AsyncIterator<CustomerEdge>>,
    Fragmentable {
  node: <T = CustomerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MainProjectPreviousValues {
  id: Int;
  shortDescription: String;
  status: Int;
  notes?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface MainProjectPreviousValuesPromise
  extends Promise<MainProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  shortDescription: () => Promise<String>;
  status: () => Promise<Int>;
  notes: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface MainProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<MainProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  notes: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AnalyzeCustomerFormConnection {
  pageInfo: PageInfo;
  edges: AnalyzeCustomerFormEdge[];
}

export interface AnalyzeCustomerFormConnectionPromise
  extends Promise<AnalyzeCustomerFormConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AnalyzeCustomerFormEdge>>() => T;
  aggregate: <T = AggregateAnalyzeCustomerFormPromise>() => T;
}

export interface AnalyzeCustomerFormConnectionSubscription
  extends Promise<AsyncIterator<AnalyzeCustomerFormConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<AnalyzeCustomerFormEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateAnalyzeCustomerFormSubscription>() => T;
}

export interface AggregateBuisness {
  count: Int;
}

export interface AggregateBuisnessPromise
  extends Promise<AggregateBuisness>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBuisnessSubscription
  extends Promise<AsyncIterator<AggregateBuisness>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MainProjectPhasesSubscriptionPayload {
  mutation: MutationType;
  node: MainProjectPhases;
  updatedFields: String[];
  previousValues: MainProjectPhasesPreviousValues;
}

export interface MainProjectPhasesSubscriptionPayloadPromise
  extends Promise<MainProjectPhasesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MainProjectPhasesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MainProjectPhasesPreviousValuesPromise>() => T;
}

export interface MainProjectPhasesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MainProjectPhasesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MainProjectPhasesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MainProjectPhasesPreviousValuesSubscription>() => T;
}

export interface ProjectPhaseEdge {
  node: ProjectPhase;
  cursor: String;
}

export interface ProjectPhaseEdgePromise
  extends Promise<ProjectPhaseEdge>,
    Fragmentable {
  node: <T = ProjectPhasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectPhaseEdgeSubscription
  extends Promise<AsyncIterator<ProjectPhaseEdge>>,
    Fragmentable {
  node: <T = ProjectPhaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MainProjectPhasesPreviousValues {
  id: ID_Output;
}

export interface MainProjectPhasesPreviousValuesPromise
  extends Promise<MainProjectPhasesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface MainProjectPhasesPreviousValuesSubscription
  extends Promise<AsyncIterator<MainProjectPhasesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ProjectManagerConnection {
  pageInfo: PageInfo;
  edges: ProjectManagerEdge[];
}

export interface ProjectManagerConnectionPromise
  extends Promise<ProjectManagerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectManagerEdge>>() => T;
  aggregate: <T = AggregateProjectManagerPromise>() => T;
}

export interface ProjectManagerConnectionSubscription
  extends Promise<AsyncIterator<ProjectManagerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectManagerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectManagerSubscription>() => T;
}

export interface BuisnessEdge {
  node: Buisness;
  cursor: String;
}

export interface BuisnessEdgePromise
  extends Promise<BuisnessEdge>,
    Fragmentable {
  node: <T = BuisnessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BuisnessEdgeSubscription
  extends Promise<AsyncIterator<BuisnessEdge>>,
    Fragmentable {
  node: <T = BuisnessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Branch {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  type: String;
}

export interface BranchPromise extends Promise<Branch>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  type: () => Promise<String>;
  buisness: <T = FragmentableArray<Buisness>>(args?: {
    where?: BuisnessWhereInput;
    orderBy?: BuisnessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: <T = AddressPromise>() => T;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BranchSubscription
  extends Promise<AsyncIterator<Branch>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  buisness: <T = Promise<AsyncIterator<BuisnessSubscription>>>(args?: {
    where?: BuisnessWhereInput;
    orderBy?: BuisnessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: <T = AddressSubscription>() => T;
  products: <T = Promise<AsyncIterator<ProductSubscription>>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = Promise<AsyncIterator<ContactSubscription>>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BranchNullablePromise
  extends Promise<Branch | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  type: () => Promise<String>;
  buisness: <T = FragmentableArray<Buisness>>(args?: {
    where?: BuisnessWhereInput;
    orderBy?: BuisnessOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  address: <T = AddressPromise>() => T;
  products: <T = FragmentableArray<Product>>(args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contacts: <T = FragmentableArray<Contact>>(args?: {
    where?: ContactWhereInput;
    orderBy?: ContactOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PermissionSubscriptionPayload {
  mutation: MutationType;
  node: Permission;
  updatedFields: String[];
  previousValues: PermissionPreviousValues;
}

export interface PermissionSubscriptionPayloadPromise
  extends Promise<PermissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionPreviousValuesPromise>() => T;
}

export interface PermissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionPreviousValuesSubscription>() => T;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PermissionPreviousValues {
  id: ID_Output;
  buisnessObj: String;
}

export interface PermissionPreviousValuesPromise
  extends Promise<PermissionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  buisnessObj: () => Promise<String>;
}

export interface PermissionPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  buisnessObj: () => Promise<AsyncIterator<String>>;
}

export interface PhasePayloadEdge {
  node: PhasePayload;
  cursor: String;
}

export interface PhasePayloadEdgePromise
  extends Promise<PhasePayloadEdge>,
    Fragmentable {
  node: <T = PhasePayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhasePayloadEdgeSubscription
  extends Promise<AsyncIterator<PhasePayloadEdge>>,
    Fragmentable {
  node: <T = PhasePayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BuisnessConnection {
  pageInfo: PageInfo;
  edges: BuisnessEdge[];
}

export interface BuisnessConnectionPromise
  extends Promise<BuisnessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BuisnessEdge>>() => T;
  aggregate: <T = AggregateBuisnessPromise>() => T;
}

export interface BuisnessConnectionSubscription
  extends Promise<AsyncIterator<BuisnessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BuisnessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBuisnessSubscription>() => T;
}

export interface PhaseFormsPayloadEdge {
  node: PhaseFormsPayload;
  cursor: String;
}

export interface PhaseFormsPayloadEdgePromise
  extends Promise<PhaseFormsPayloadEdge>,
    Fragmentable {
  node: <T = PhaseFormsPayloadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PhaseFormsPayloadEdgeSubscription
  extends Promise<AsyncIterator<PhaseFormsPayloadEdge>>,
    Fragmentable {
  node: <T = PhaseFormsPayloadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PermissionActionSubscriptionPayload {
  mutation: MutationType;
  node: PermissionAction;
  updatedFields: String[];
  previousValues: PermissionActionPreviousValues;
}

export interface PermissionActionSubscriptionPayloadPromise
  extends Promise<PermissionActionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionActionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionActionPreviousValuesPromise>() => T;
}

export interface PermissionActionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionActionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionActionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionActionPreviousValuesSubscription>() => T;
}

export interface PermissionActionConnection {
  pageInfo: PageInfo;
  edges: PermissionActionEdge[];
}

export interface PermissionActionConnectionPromise
  extends Promise<PermissionActionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionActionEdge>>() => T;
  aggregate: <T = AggregatePermissionActionPromise>() => T;
}

export interface PermissionActionConnectionSubscription
  extends Promise<AsyncIterator<PermissionActionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionActionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionActionSubscription>() => T;
}

export interface PermissionActionPreviousValues {
  id: ID_Output;
  type?: String;
  roles: String[];
}

export interface PermissionActionPreviousValuesPromise
  extends Promise<PermissionActionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  roles: () => Promise<String[]>;
}

export interface PermissionActionPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionActionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  roles: () => Promise<AsyncIterator<String[]>>;
}

export interface ProjectPhaseSubscriptionPayload {
  mutation: MutationType;
  node: ProjectPhase;
  updatedFields: String[];
  previousValues: ProjectPhasePreviousValues;
}

export interface ProjectPhaseSubscriptionPayloadPromise
  extends Promise<ProjectPhaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPhasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPhasePreviousValuesPromise>() => T;
}

export interface ProjectPhaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectPhaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectPhaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPhasePreviousValuesSubscription>() => T;
}

export interface AggregateBranch {
  count: Int;
}

export interface AggregateBranchPromise
  extends Promise<AggregateBranch>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBranchSubscription
  extends Promise<AsyncIterator<AggregateBranch>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateMainProjectPhases {
  count: Int;
}

export interface AggregateMainProjectPhasesPromise
  extends Promise<AggregateMainProjectPhases>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMainProjectPhasesSubscription
  extends Promise<AsyncIterator<AggregateMainProjectPhases>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PhaseFormsPayloadSubscriptionPayload {
  mutation: MutationType;
  node: PhaseFormsPayload;
  updatedFields: String[];
  previousValues: PhaseFormsPayloadPreviousValues;
}

export interface PhaseFormsPayloadSubscriptionPayloadPromise
  extends Promise<PhaseFormsPayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhaseFormsPayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhaseFormsPayloadPreviousValuesPromise>() => T;
}

export interface PhaseFormsPayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhaseFormsPayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhaseFormsPayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhaseFormsPayloadPreviousValuesSubscription>() => T;
}

export interface ProjectForms {
  id: ID_Output;
}

export interface ProjectFormsPromise
  extends Promise<ProjectForms>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  criteriaCalculator: <T = CriteriaCalculatorPromise>() => T;
}

export interface ProjectFormsSubscription
  extends Promise<AsyncIterator<ProjectForms>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  criteriaCalculator: <T = CriteriaCalculatorSubscription>() => T;
}

export interface ProjectFormsNullablePromise
  extends Promise<ProjectForms | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  criteriaCalculator: <T = CriteriaCalculatorPromise>() => T;
}

export interface PhaseFormsPayloadPreviousValues {
  id: ID_Output;
  until?: DateTimeOutput;
  required: Boolean;
  document: String;
  taskTitle: String;
}

export interface PhaseFormsPayloadPreviousValuesPromise
  extends Promise<PhaseFormsPayloadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  until: () => Promise<DateTimeOutput>;
  required: () => Promise<Boolean>;
  document: () => Promise<String>;
  taskTitle: () => Promise<String>;
}

export interface PhaseFormsPayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<PhaseFormsPayloadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  until: () => Promise<AsyncIterator<DateTimeOutput>>;
  required: () => Promise<AsyncIterator<Boolean>>;
  document: () => Promise<AsyncIterator<String>>;
  taskTitle: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BranchEdge {
  node: Branch;
  cursor: String;
}

export interface BranchEdgePromise extends Promise<BranchEdge>, Fragmentable {
  node: <T = BranchPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BranchEdgeSubscription
  extends Promise<AsyncIterator<BranchEdge>>,
    Fragmentable {
  node: <T = BranchSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LeadConnection {
  pageInfo: PageInfo;
  edges: LeadEdge[];
}

export interface LeadConnectionPromise
  extends Promise<LeadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LeadEdge>>() => T;
  aggregate: <T = AggregateLeadPromise>() => T;
}

export interface LeadConnectionSubscription
  extends Promise<AsyncIterator<LeadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LeadEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLeadSubscription>() => T;
}

export interface PhasePayloadSubscriptionPayload {
  mutation: MutationType;
  node: PhasePayload;
  updatedFields: String[];
  previousValues: PhasePayloadPreviousValues;
}

export interface PhasePayloadSubscriptionPayloadPromise
  extends Promise<PhasePayloadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PhasePayloadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PhasePayloadPreviousValuesPromise>() => T;
}

export interface PhasePayloadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PhasePayloadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PhasePayloadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PhasePayloadPreviousValuesSubscription>() => T;
}

export interface CustomerConnection {
  pageInfo: PageInfo;
  edges: CustomerEdge[];
}

export interface CustomerConnectionPromise
  extends Promise<CustomerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CustomerEdge>>() => T;
  aggregate: <T = AggregateCustomerPromise>() => T;
}

export interface CustomerConnectionSubscription
  extends Promise<AsyncIterator<CustomerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CustomerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCustomerSubscription>() => T;
}

export interface PhasePayloadPreviousValues {
  id: ID_Output;
  aktiv: Boolean;
}

export interface PhasePayloadPreviousValuesPromise
  extends Promise<PhasePayloadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  aktiv: () => Promise<Boolean>;
}

export interface PhasePayloadPreviousValuesSubscription
  extends Promise<AsyncIterator<PhasePayloadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  aktiv: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface BranchConnection {
  pageInfo: PageInfo;
  edges: BranchEdge[];
}

export interface BranchConnectionPromise
  extends Promise<BranchConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BranchEdge>>() => T;
  aggregate: <T = AggregateBranchPromise>() => T;
}

export interface BranchConnectionSubscription
  extends Promise<AsyncIterator<BranchConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BranchEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBranchSubscription>() => T;
}

export interface ProjectFormsEdge {
  node: ProjectForms;
  cursor: String;
}

export interface ProjectFormsEdgePromise
  extends Promise<ProjectFormsEdge>,
    Fragmentable {
  node: <T = ProjectFormsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectFormsEdgeSubscription
  extends Promise<AsyncIterator<ProjectFormsEdge>>,
    Fragmentable {
  node: <T = ProjectFormsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  shortDescription: String;
  description: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePermissionAction {
  count: Int;
}

export interface AggregatePermissionActionPromise
  extends Promise<AggregatePermissionAction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionActionSubscription
  extends Promise<AsyncIterator<AggregatePermissionAction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Contact {
  id: ID_Output;
  profileImage?: String;
  email?: String;
  firstname: String;
  lastname?: String;
  nickname?: String;
  telephone?: String;
  mobile?: String;
  position?: String;
  notes?: String;
}

export interface ContactPromise extends Promise<Contact>, Fragmentable {
  id: () => Promise<ID_Output>;
  profileImage: () => Promise<String>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  nickname: () => Promise<String>;
  telephone: () => Promise<String>;
  mobile: () => Promise<String>;
  position: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface ContactSubscription
  extends Promise<AsyncIterator<Contact>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  profileImage: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  firstname: () => Promise<AsyncIterator<String>>;
  lastname: () => Promise<AsyncIterator<String>>;
  nickname: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
  mobile: () => Promise<AsyncIterator<String>>;
  position: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface ContactNullablePromise
  extends Promise<Contact | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  profileImage: () => Promise<String>;
  email: () => Promise<String>;
  firstname: () => Promise<String>;
  lastname: () => Promise<String>;
  nickname: () => Promise<String>;
  telephone: () => Promise<String>;
  mobile: () => Promise<String>;
  position: () => Promise<String>;
  notes: () => Promise<String>;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectPreviousValues {
  id: Int;
  status: Int;
  shortDescription: String;
  notes?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  status: () => Promise<Int>;
  shortDescription: () => Promise<String>;
  notes: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCustomer {
  count: Int;
}

export interface AggregateCustomerPromise
  extends Promise<AggregateCustomer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCustomerSubscription
  extends Promise<AsyncIterator<AggregateCustomer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  shortDescription: String;
  description: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  shortDescription: () => Promise<String>;
  description: () => Promise<String>;
}

export interface AggregateProjectManager {
  count: Int;
}

export interface AggregateProjectManagerPromise
  extends Promise<AggregateProjectManager>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectManagerSubscription
  extends Promise<AsyncIterator<AggregateProjectManager>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectFormsSubscriptionPayload {
  mutation: MutationType;
  node: ProjectForms;
  updatedFields: String[];
  previousValues: ProjectFormsPreviousValues;
}

export interface ProjectFormsSubscriptionPayloadPromise
  extends Promise<ProjectFormsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectFormsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectFormsPreviousValuesPromise>() => T;
}

export interface ProjectFormsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectFormsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectFormsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectFormsPreviousValuesSubscription>() => T;
}

export interface ProjectPhasePreviousValues {
  id: ID_Output;
  name: String;
  status?: Int;
  roles: String[];
  users: String[];
}

export interface ProjectPhasePreviousValuesPromise
  extends Promise<ProjectPhasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  status: () => Promise<Int>;
  roles: () => Promise<String[]>;
  users: () => Promise<String[]>;
}

export interface ProjectPhasePreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPhasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<Int>>;
  roles: () => Promise<AsyncIterator<String[]>>;
  users: () => Promise<AsyncIterator<String[]>>;
}

export interface MainProjectPhasesConnection {
  pageInfo: PageInfo;
  edges: MainProjectPhasesEdge[];
}

export interface MainProjectPhasesConnectionPromise
  extends Promise<MainProjectPhasesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MainProjectPhasesEdge>>() => T;
  aggregate: <T = AggregateMainProjectPhasesPromise>() => T;
}

export interface MainProjectPhasesConnectionSubscription
  extends Promise<AsyncIterator<MainProjectPhasesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MainProjectPhasesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMainProjectPhasesSubscription>() => T;
}

export interface ProjectManagerPreviousValues {
  id: ID_Output;
  order: Int;
  notes?: String;
}

export interface ProjectManagerPreviousValuesPromise
  extends Promise<ProjectManagerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  order: () => Promise<Int>;
  notes: () => Promise<String>;
}

export interface ProjectManagerPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectManagerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  order: () => Promise<AsyncIterator<Int>>;
  notes: () => Promise<AsyncIterator<String>>;
}

export interface ProjectManagerSubscriptionPayload {
  mutation: MutationType;
  node: ProjectManager;
  updatedFields: String[];
  previousValues: ProjectManagerPreviousValues;
}

export interface ProjectManagerSubscriptionPayloadPromise
  extends Promise<ProjectManagerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectManagerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectManagerPreviousValuesPromise>() => T;
}

export interface ProjectManagerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectManagerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectManagerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectManagerPreviousValuesSubscription>() => T;
}

export interface Buisness {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  shortDescription: String;
  longDescription: String;
}

export interface BuisnessPromise extends Promise<Buisness>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  shortDescription: () => Promise<String>;
  longDescription: () => Promise<String>;
}

export interface BuisnessSubscription
  extends Promise<AsyncIterator<Buisness>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  shortDescription: () => Promise<AsyncIterator<String>>;
  longDescription: () => Promise<AsyncIterator<String>>;
}

export interface BuisnessNullablePromise
  extends Promise<Buisness | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  shortDescription: () => Promise<String>;
  longDescription: () => Promise<String>;
}

export interface ProjectFormsPreviousValues {
  id: ID_Output;
}

export interface ProjectFormsPreviousValuesPromise
  extends Promise<ProjectFormsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ProjectFormsPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectFormsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateLead {
  count: Int;
}

export interface AggregateLeadPromise
  extends Promise<AggregateLead>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLeadSubscription
  extends Promise<AsyncIterator<AggregateLead>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PermissionEdge {
  node: Permission;
  cursor: String;
}

export interface PermissionEdgePromise
  extends Promise<PermissionEdge>,
    Fragmentable {
  node: <T = PermissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionEdgeSubscription
  extends Promise<AsyncIterator<PermissionEdge>>,
    Fragmentable {
  node: <T = PermissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Lead",
    embedded: false
  },
  {
    name: "Customer",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "ProjectManager",
    embedded: false
  },
  {
    name: "Buisness",
    embedded: false
  },
  {
    name: "Address",
    embedded: false
  },
  {
    name: "Branch",
    embedded: false
  },
  {
    name: "Contact",
    embedded: false
  },
  {
    name: "PermissionAction",
    embedded: false
  },
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "MainProject",
    embedded: false
  },
  {
    name: "MainProjectPhases",
    embedded: false
  },
  {
    name: "PhasePayload",
    embedded: false
  },
  {
    name: "PhaseFormsPayload",
    embedded: false
  },
  {
    name: "AnalyzeCustomerForm",
    embedded: false
  },
  {
    name: "ProjectPhase",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "ProjectForms",
    embedded: false
  },
  {
    name: "CriteriaCalculator",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `https://pra-project.herokuapp.com/PraProject/dev`
});
export const prisma = new Prisma();
